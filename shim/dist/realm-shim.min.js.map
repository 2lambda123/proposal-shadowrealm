{"version":3,"file":"realm-shim.min.js","sources":["../src/realmFacade.js","../src/stdlib.js","../src/accessors.js","../src/functions.js","../src/unsafeRec.js","../src/block-imports.js","../src/utilities.js","../src/evaluators.js","../src/realm.js","../src/commons.js","../src/scopeHandler.js"],"sourcesContent":["// Note: do not import anything to this file to prevent using implicit\n// dependencies.\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\n// todo: This function is stringified and evaluated outside of the primal\n// realms and it currently can't contain code coverage metrics.\n/* istanbul ignore next */\nfunction buildChildRealm({ initRootRealm, initCompartment, getRealmGlobal, realmEvaluate }) {\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. We extract these\n  // properties for brevity, not for security. Don't ever run this function\n  // *after* user code has had a chance to pollute its environment, or it\n  // could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { defineProperty } = Object;\n\n  const errorConstructors = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n\n  // Like Realm.apply except that it catches anything thrown and rethrows it\n  // as an Error from this realm\n  function callAndWrapError(target, ...args) {\n    try {\n      return target(...args);\n    } catch (err) {\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n      let eName, eMessage, eStack;\n      try {\n        // The child environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\n        // string coercion of 'err.name'. If err.name is an object (probably\n        // a String of the parent Realm), the coercion uses\n        // err.name.toString(), which is under the control of the parent. If\n        // err.name were a primitive (e.g. a number), it would use\n        // Number.toString(err.name), using the child's version of Number\n        // (which the child could modify to capture its argument for later\n        // use), however primitives don't have properties like .prototype so\n        // they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack}`;\n        // eName/eMessage/eStack are now child-realm primitive strings, and\n        // safe to expose\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away\n        // from the child\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  class Realm {\n    static makeRootRealm(...args) {\n      const r = new Realm();\n      callAndWrapError(initRootRealm, Realm, r, ...args);\n      return r;\n    }\n\n    static makeCompartment(...args) {\n      const r = new Realm();\n      callAndWrapError(initCompartment, Realm, r, ...args);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, this);\n    }\n\n    evaluate(...args) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, this, ...args);\n    }\n  }\n\n  defineProperty(Realm.prototype, 'toString', {\n    value: () => 'function Realm() { [shim code] }',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  return Realm;\n}\n\n// the parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = `'use strict'; (${buildChildRealm})`;\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(BaseRealm);\n}\n","// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable.\nconst sharedGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  'Date',\n  'Error',\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function', // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  'Promise',\n  'Proxy',\n  'RangeError',\n  'ReferenceError',\n  'RegExp',\n  'Set',\n  // 'SharedArrayBuffer' // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape',\n\n  // *** ECMA-402\n\n  'Intl'\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {\n    // *** 18.1 Value Properties of the Global Object\n    Infinity: { value: Infinity },\n    NaN: { value: NaN },\n    undefined: { value: undefined }\n  };\n\n  for (const name of sharedGlobalPropertyNames) {\n    descriptors[name] = {\n      // todo: if there's a get/accessor on the global, do we want to invoke\n      // it or throw an error?\n      // todo: get a descriptor here, so we can check\n      value: unsafeGlobal[name],\n      writable: true,\n      configurable: true\n    };\n  }\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'.\n *\n * todo: list the issues resolved\n *\n * This function can be used in two ways: (1) invoked directly to fix the primal\n * realm's Object.prototype, and (2) converted to a string to be executed\n * inside each new RootRealm to fix their Object.prototypes. Evaluation requires\n * the function to have no dependencies, so don't import anything from the outside.\n */\n\n// todo: this file should be moved out to a separate repo and npm module.\n\n// todo: This function is stringified and evaluated outside of the primal\n// realms and it currently can't contain code coverage metrics.\n/* istanbul ignore file */\nexport function repairAccessors() {\n  const {\n    getPrototypeOf,\n    defineProperty,\n    getOwnPropertyDescriptor,\n    prototype: objectPrototype\n  } = Object;\n\n  // On some platforms, the implementation of these functions act as if they are\n  // in sloppy mode: if they're invoked badly, they will expose the global object,\n  // so we need to repair these for security. Thus it is our responsibility to fix\n  // this, and we need to include repairAccessors. E.g. Chrome in 2016.\n\n  // todo: this shim should only be applied if the security bug is present.\n\n  function makeDefineAccessor(method, accessor) {\n    defineProperty(objectPrototype, method, {\n      value(prop, func) {\n        const result = defineProperty(this, prop, {\n          [accessor]: func,\n          enumerable: true,\n          configurable: true\n        });\n        // Note that we cannot assume that defineProperty reports failure by throwing.\n        // To fix an obscure problem (link needed), defineProperty is now allowed to\n        // report failure by returning false as well.\n        if (result === false) {\n          throw new TypeError(`Cannot redefine property: ${[prop]}`);\n        }\n      }\n    });\n  }\n\n  makeDefineAccessor('__defineGetter__', 'get');\n  makeDefineAccessor('__defineSetter__', 'set');\n\n  // TOCTTOU and .asString() games could enable attacker to skip some\n  // intermediate ancestors, so we stringify/propify this once, first.\n  function asPropertyName(prop) {\n    if (typeof prop === 'symbol') {\n      return prop;\n    }\n    return `${prop}`;\n  }\n\n  function makeLookupAccessor(method, accessor) {\n    defineProperty(objectPrototype, method, {\n      value(prop) {\n        prop = asPropertyName(prop); // sanitize property name/symbol\n        let base = this;\n        let desc;\n        while (base && !(desc = getOwnPropertyDescriptor(base, prop))) {\n          base = getPrototypeOf(base);\n        }\n        return desc && desc[accessor];\n      }\n    });\n  }\n\n  makeLookupAccessor('__lookupGetter__', 'get');\n  makeLookupAccessor('__lookupSetter__', 'set');\n}\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked. \n *\n * These are all reachable via syntax, so it isn't sufficient to just \n * replace global properties with safe versions. Our main goal is to prevent \n * access to the Function constructor through these starting points.\n\n * After this block is done, the originals must no longer be reachable, unless \n * a copy has been made, and funtions can only be created by syntax (using eval) \n * or by invoking a previously saved reference to the originals.\n */\n\n// todo: This function is stringified and evaluated outside of the primal\n// realms and it currently can't contain code coverage metrics.\n/* istanbul ignore file */\nexport function repairFunctions() {\n  const { defineProperty, getPrototypeOf, setPrototypeOf } = Object;\n\n  /**\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, declaration) {\n    let FunctionInstance;\n    try {\n      // Use Function() because eval() has issues with serializing functions under the esm module.\n      // TODO: investigate esm distortion of source code.\n      // eslint-disable-next-line no-new-func\n      FunctionInstance = Function(`return ${declaration}`)();\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the prototype of functions.\n    // eslint-disable-next-line no-new-func\n    const TamedFunction = Function('throw new Error(\"Not available\");');\n    defineProperty(TamedFunction, 'name', { value: name });\n\n    // (new Error()).constructors does not inherit from Function, because Error\n    // was defined before ES6 classes. So we don't need to repair it too.\n\n    // (Error()).constructor inherit from Function, which gets a tamed constructor here.\n\n    // todo: in an ES6 class that does not inherit from anything, what does its\n    // constructor inherit from? We worry that it inherits from Function, in\n    // which case instances could give access to unsafeFunction. markm says\n    // we're fine: the constructor inherits from Object.prototype\n\n    // This line replaces the original constructor in the prototype chain\n    // with the tamed one. No copy of the original is peserved.\n    defineProperty(FunctionPrototype, 'constructor', { value: TamedFunction });\n\n    // This line sets the tamed constructor's prototype data property to\n    // the original one.\n    defineProperty(TamedFunction, 'prototype', { value: FunctionPrototype });\n\n    if (TamedFunction !== Function.prototype.constructor) {\n      // Ensures that all functions meet \"instanceof Function\" in a realm.\n      setPrototypeOf(TamedFunction, Function.prototype.constructor);\n    }\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the tamed\n  // Function function constructor.\n\n  // note: this really wants to be part of the standard, because new\n  // constructors may be added in the future, reachable from syntax, and this\n  // list must be updated to match.\n\n  repairFunction('Function', '(function(){})');\n  // \"plain arrow functions\" inherit from Function.prototype\n  repairFunction('GeneratorFunction', '(function*(){})');\n  repairFunction('AsyncFunction', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '(async function*(){})');\n}\n","// this module must never be importable outside the Realm shim itself\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors } from './accessors';\nimport { repairFunctions } from './functions';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// Detection used in RollupJS.\nconst isNode = typeof exports === 'object' && typeof module !== 'undefined';\nconst isBrowser = typeof document === 'object';\nif ((!isNode && !isBrowser) || (isNode && isBrowser)) {\n  throw new Error('unexpected platform, unable to create Realm');\n}\nconst vm = isNode ? require('vm') : undefined;\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\nfunction createNewUnsafeGlobalForNode() {\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\nfunction createNewUnsafeGlobalForBrowser() {\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n  // todo: we keep the iframe attached. At one point, removing the iframe\n  // caused its global object to lose its intrinsics. todo: re-test this.\n\n  return unsafeGlobal;\n}\n\n// we only export this so test-repair.js can get an unrepaired\n// Object.prototype, to sense if this platform has the buggy behavior\nexport const getNewUnsafeGlobal = isNode\n  ? createNewUnsafeGlobalForNode\n  : createNewUnsafeGlobalForBrowser;\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval: unsafeGlobal.eval,\n    unsafeFunction: unsafeGlobal.Function,\n    allShims\n  });\n}\n\nconst repairAccessorsShim = `\"use strict\"; (${repairAccessors})();`;\nconst repairFunctionsShim = `\"use strict\"; (${repairFunctions})();`;\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  unsafeGlobal.eval(repairAccessorsShim);\n  unsafeGlobal.eval(repairFunctionsShim);\n  return createUnsafeRec(unsafeGlobal, allShims);\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  repairAccessors();\n  repairFunctions();\n  return createUnsafeRec(unsafeGlobal, []);\n}\n","// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst scanner = /^(.*)\\bimport\\s*(\\(|\\/\\/|\\/\\*)/m;\n\nexport function rejectImportExpressions(s) {\n  const matches = scanner.exec(s);\n  if (matches) {\n    // todo: if we have a full parser available, use it here. If there is no\n    // 'import' token in the string, we're safe.\n    // if (!parse(s).contains('import')) return;\n    const linenum = matches[1].split('\\n').length; // more or less\n    throw new SyntaxError(`possible import expression rejected around line ${linenum}`);\n  }\n}\n","// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n\n  // note: we really do want to log these 'should never happen' things. there\n  // might be a better way to convince the linter, though.\n  // eslint-disable-next-line no-console\n  console.error(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.error(`${err}`);\n    // eslint-disable-next-line no-console\n    console.error(`${err.stack}`);\n  }\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(`failed to: ${message}`);\n  }\n}\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  apply,\n  arrayJoin,\n  arrayPop,\n  arrayPush,\n  create,\n  defineProperty,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  regexpMatch,\n  arrayForEach,\n  setPrototypeOf,\n  stringIncludes\n} from './commons';\nimport { ScopeHandler } from './scopeHandler';\nimport { rejectImportExpressions } from './block-imports';\nimport { assert, throwTantrum } from './utilities';\n\nconst identifierPattern = /^[a-zA-Z_$][\\w_$]*$/;\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\nfunction getOptimizableGlobals(safeGlobal) {\n  const constants = [];\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  arrayForEach(getOwnPropertyNames(descs), name => {\n    const desc = descs[name];\n    if (typeof name !== 'string') return; // ignore Symbols\n\n    // admit many (but not all) legal variable names: starts with letter/_/$,\n    // continues with letter/digit/_/$ . It will reject many legal names that\n    // involve unicode characters. We use 'apply' rather than /../.match() in\n    // case RegExp has been poisoned.\n\n    if (!regexpMatch(identifierPattern, name)) return;\n\n    // todo: reject keywords, which pass the isIdentifier check, to block\n    // injection attacks. test should use a property name that is itself a\n    // full program\n\n    // getters will not have .writable, don't let the falsyness of\n    // 'undefined' trick us: test with === false, not ! . However descriptors\n    // inherit from the (potentially poisoned) global object, so we might see\n    // extra properties which weren't really there. Accessor properties have\n    // 'get/set/enumerable/configurable', while data properties have\n    // 'value/writable/enumerable/configurable'.\n\n    if (desc.configurable !== false) return;\n    if (desc.writable !== false) return;\n\n    // Check for accessor properties: we don't want to optimize these,\n    // they're obviously non-constant. Setter-only accessors will still have\n    // a 'get' property, but it will be 'undefined', so we only have to test\n    // for 'get', not 'set'\n    if ('get' in desc) return;\n    if ('set' in desc) return;\n\n    // protect against post-initialization corruption of primal realm Array\n    arrayPush(constants, name);\n  });\n  return constants;\n}\n\nfunction buildOptimizer(constants) {\n  return `const {${arrayJoin(constants, ',')}} = arguments[0];`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  // todo: This function is stringified and evaluated outside of the primal\n  // realms and it currently can't contain code coverage metrics.\n  /* istanbul ignore next */\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluatorFactory(unsafeRec, safeGlobal) {\n  const { unsafeFunction } = unsafeRec;\n\n  const scopeHandler = new ScopeHandler(unsafeRec);\n  const optimizableGlobals = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(unsafeRec, optimizableGlobals);\n\n  function factory(endowments) {\n    // todo (shim limitation): scan endowments, throw error if endowment\n    // overlaps with the const optimization (which would otherwise\n    // incorrectly shadow endowments), or if endowments includes 'eval'. Also\n    // prohibit accessor properties (to be able to consistently explain\n    // things in terms of shimming the global lexical scope).\n    // writeable-vs-nonwritable == let-vs-const, but there's no\n    // global-lexical-scope equivalent of an accessor, outside what we can\n    // explain/spec\n    const scopeTarget = create(safeGlobal, getOwnPropertyDescriptors(endowments));\n    const scopeProxy = new Proxy(scopeTarget, scopeHandler);\n    const scopedEvaluator = scopedEvaluatorFactory(scopeProxy);\n\n    // We use the the concise method syntax to create an eval without a\n    // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n    // TypeError: eval is not a constructor\"), but which still accepts a\n    // 'this' binding.\n    const safeEval = {\n      eval(src) {\n        src = `${src}`;\n        rejectImportExpressions(src);\n        scopeHandler.useUnsafeEvaluator = true;\n        let err;\n        try {\n          // Ensure that \"this\" resolves to the safe global.\n          return apply(scopedEvaluator, safeGlobal, [src]);\n        } catch (e) {\n          // stash the child-code error in hopes of debugging the internal failure\n          err = e;\n          throw e;\n        } finally {\n          // belt and suspenders: the proxy switches this off immediately after\n          // the first access, but just in case we clear it here too\n          if (scopeHandler.useUnsafeEvaluator !== false) {\n            scopeHandler.useUnsafeEvaluator = false;\n            throwTantrum('handler sets useUnsafeEvaluator = false', err);\n          }\n        }\n      }\n    }.eval;\n\n    // safeEval's prototype is currently the primal realm's\n    // Function.prototype, which we must not let escape. To make 'eval\n    // instanceof Function' be true inside the realm, we need to point it at\n    // the RootRealm's value.\n\n    // Ensure that eval from any compartment in a root realm is an instance\n    // of Function in any compartment of the same root realm.\n    setPrototypeOf(safeEval, unsafeFunction.prototype);\n\n    assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n    assert(getPrototypeOf(safeEval).constructor !== unsafeFunction, 'hide unsafeFunction');\n\n    // note: be careful to not leak our primal Function.prototype by setting\n    // this to a plain arrow function. Now that we have safeEval, use it.\n    defineProperty(safeEval, 'toString', {\n      value: safeEval(\"() => 'function eval() { [shim code] }'\"),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n\n    return safeEval;\n  }\n\n  return factory;\n}\n\nexport function createSafeEvaluator(safeEvaluatorFactory) {\n  return safeEvaluatorFactory({});\n}\n\nexport function createSafeEvaluatorWhichTakesEndowments(safeEvaluatorFactory) {\n  return (x, endowments) => safeEvaluatorFactory(endowments)(x);\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  const safeFunction = function Function(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEval(src);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\n\n  assert(getPrototypeOf(safeFunction).constructor !== Function, 'hide Function');\n  assert(getPrototypeOf(safeFunction).constructor !== unsafeFunction, 'hide unsafeFunction');\n\n  // Ensure that any function created in any compartment in a root realm is an\n  // instance of Function in any compartment of the same root ralm.\n  defineProperty(safeFunction, 'prototype', { value: unsafeFunction.prototype });\n\n  // Provide a custom output without overwriting the Function.prototype.toString\n  // which is called by some third-party libraries.\n  defineProperty(safeFunction, 'toString', {\n    value: safeEval(\"() => 'function Function() { [shim code] }'\"),\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  return safeFunction;\n}\n","import { createRealmFacade } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport {\n  createSafeEvaluatorFactory,\n  createSafeEvaluator,\n  createSafeEvaluatorWhichTakesEndowments,\n  createFunctionEvaluator\n} from './evaluators';\nimport { create, defineProperty, defineProperties, freeze, arrayConcat } from './commons';\n\n// Create a registry to mimic a private static members on the realm classes.\n// We define it in the same module and do not export it.\n\nconst UnsafeRecForRealmClass = new WeakMap();\n\nfunction getUnsafeRecForRealmClass(RealmClass) {\n  if (Object(RealmClass) !== RealmClass) {\n    // Detect non-objects.\n    throw new TypeError('internal error: bad object, not a Realm constructor');\n  }\n  // spec just says throw TypeError\n  // todo: but shim should include a message\n  if (!UnsafeRecForRealmClass.has(RealmClass)) {\n    // RealmClass has no unsafeRec. Shoud not proceed.\n    throw new TypeError('internal error: bad object');\n  }\n  return UnsafeRecForRealmClass.get(RealmClass);\n}\n\nfunction registerUnsafeRecForRealmClass(RealmClass, unsafeRec) {\n  if (Object(RealmClass) !== RealmClass) {\n    // Detect non-objects.\n    throw new TypeError('internal error: bad object, not a Realm constructor');\n  }\n  // spec just says throw TypeError\n  // todo: but shim should include a message\n  if (UnsafeRecForRealmClass.has(RealmClass)) {\n    // Attempt to change an existing unsafeRec on a Realm. Shoud not proceed.\n    throw new TypeError('internal error: bad object');\n  }\n  UnsafeRecForRealmClass.set(RealmClass, unsafeRec);\n}\n\n// Create a registry to mimic a private members on the realm imtances.\n// We define it in the same module and do not export it.\n\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  if (Object(realm) !== realm) {\n    // Detect non-objects.\n    throw new TypeError('bad object, not a Realm instance');\n  }\n  if (!RealmRecForRealmInstance.has(realm)) {\n    // Realm instance has no realmRec. Should not proceed.\n    throw new TypeError(\n      'bad object, use Realm.makeRootRealm() or .makeCompartment() instead of \"new Realm\"'\n    );\n  }\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  if (Object(realm) !== realm) {\n    // Detect non-objects.\n    throw new TypeError('internal error: bad object, not a Realm instance');\n  }\n  if (RealmRecForRealmInstance.has(realm)) {\n    // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n    throw new TypeError('internal error: Realm instance is already present');\n  }\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(sharedGlobalDescs, safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, sharedGlobalDescs);\n\n  defineProperty(safeGlobal, 'eval', {\n    value: safeEval,\n    writable: true,\n    configurable: true\n  });\n\n  defineProperty(safeGlobal, 'Function', {\n    value: safeFunction,\n    writable: true,\n    configurable: true\n  });\n}\n\nfunction createRealmRec(unsafeRec) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype);\n  const safeEvaluatorFactory = createSafeEvaluatorFactory(unsafeRec, safeGlobal);\n  const safeEval = createSafeEvaluator(safeEvaluatorFactory);\n  const safeEvalWhichTakesEndowments = createSafeEvaluatorWhichTakesEndowments(\n    safeEvaluatorFactory\n  );\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\n\n  setDefaultBindings(sharedGlobalDescs, safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeEvalWhichTakesEndowments,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\nfunction initRootRealm(selfClass, self, options) {\n  options = Object(options); // Todo: sanitize\n  // note: 'self' is the instance of the Realm, and 'selfClass' is the\n  // Realm constructor (facade) we build in buildChildRealm().\n\n  // In 'undefined' mode, intrinics are not provided, we create a root\n  // realm using the fresh set of new intrinics from a new context.\n\n  // todo: investigate attacks via Array.species\n  const newShims = options.shims || [];\n  const { allShims: oldShims } = getUnsafeRecForRealmClass(selfClass);\n  // todo: this accepts newShims='string', but it should reject that\n  const allShims = arrayConcat(oldShims, newShims);\n\n  // The unsafe record is returned with its constructors repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // Define Realm onto new sharedGlobalDescs, so it can be copied onto the\n  // safeGlobal like the rest of the .\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmGlobalObject(unsafeRec);\n  registerUnsafeRecForRealmClass(Realm, unsafeRec);\n\n  const realmRec = createRealmRec(unsafeRec);\n  registerRealmRecForRealmInstance(self, realmRec);\n  // Now run all shims in the new RootRealm. We don't do this for\n  // compartments\n  for (const shim of allShims) {\n    // eslint-disable-next-line no-use-before-define\n    realmEvaluate(self, shim);\n  }\n}\n\nfunction initCompartment(selfClass, self) {\n  // note: 'self' is the instance of the Realm, and 'selfClass' is the\n  // Realm constructor (facade) we build in buildChildRealm().\n\n  // In \"inherit\" mode, we create a compartment realm and inherit\n  // the context since we share the intrinsics. We create a new\n  // set to allow us to define eval() and Function() for the realm.\n  const unsafeRec = getUnsafeRecForRealmClass(selfClass);\n\n  const realmRec = createRealmRec(unsafeRec);\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x, endowments = {}) {\n  // todo: don't pass in primal-realm objects like {}, for safety. OTOH its\n  // properties are copied onto the new global 'target'.\n  // todo: figure out a way to membrane away the contents to safety.\n  const { safeEvalWhichTakesEndowments } = getRealmRecForRealmInstance(self);\n  return safeEvalWhichTakesEndowments(x, endowments);\n}\n\n// Define Realm onto new sharedGlobalDescs, so it can be defined in the\n// safeGlobal like the rest of the shared globals.\nfunction createRealmGlobalObject(unsafeRec) {\n  const Realm = createRealmFacade(unsafeRec, {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  });\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n  return Realm;\n}\n\n// Create the current unsafeRec from the current \"primal\" realm (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\nconst Realm = createRealmFacade(currentUnsafeRec, {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n});\nregisterUnsafeRecForRealmClass(Realm, currentUnsafeRec);\n\nexport default Realm;\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  defineProperties,\n  defineProperty,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables, unlike Object.keys()\n} = Reflect;\n\n// See http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n// which only lives at http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n// (the native call is about 10x faster on FF than chrome)\n// this version of uncurryThis is about 100x slower on FF, equal on chrome, 2x slower on Safari\n// const bind = Function.prototype.bind;\n// const uncurryThis = bind.bind(bind.call);\n\n// this version is about 10x slower on FF, equal on chrome, 2x slower on Safari\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpMatch = uncurryThis(RegExp.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","// the ScopeHandler manages a Proxy which serves as the global scope for the\n// safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n// As described in createSafeEvaluator(), it has several functions:\n// * allow the very first (and only the very first) use of 'eval' to map to\n//   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n//   access its lexical scope (which maps to the 'with' binding, which the\n//   ScopeHandler also controls)\n// * ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n//   which lives as the 'eval' property of the safeGlobal\n// * route all other property lookups at the safeGlobal\n// * hide the unsafeGlobal which lives on the scope chain above the 'with'\n// * ensure the Proxy invariants despite some global properties being frozen\n\nimport { getPrototypeOf, objectHasOwnProperty } from './commons';\n\nexport class ScopeHandler {\n  // Properties stored on the handler are not available from the proxy.\n\n  // the Proxy is only used by with(), so the Handler only needs to implement\n  // a few properties: has, get, set (which we leave at the default)\n\n  // todo: throw if any traps other than get/set/has are run (e.g.\n  // getOwnPropertyDescriptors, apply, getPrototypeOf) . Make this handler\n  // inherit from a second one whose 'get' property always throws.\n\n  constructor(unsafeRec) {\n    this.unsafeGlobal = unsafeRec.unsafeGlobal;\n    this.unsafeEval = unsafeRec.unsafeEval;\n\n    // this flag allow us to determine if the eval() call is a controlled\n    // eval done by the realm's code or if it is user-land invocation, so\n    // we can react differently.\n    this.useUnsafeEvaluator = false;\n\n    // todo: this.shadowTarget = getPrototypeOf(somehow_get_target)\n  }\n\n  get(target, prop) {\n    // Special treatment for eval. The very first lookup of 'eval' gets the\n    // unsafe (real direct) eval, so it will get the lexical scope that uses\n    // the 'with' context.\n    if (prop === 'eval') {\n      // test that it is true rather than merely truthy\n      if (this.useUnsafeEvaluator === true) {\n        // reset before use\n        this.useUnsafeEvaluator = false;\n        return this.unsafeEval;\n      }\n      return target.eval;\n    }\n\n    // todo: shim integrity, capture Symbol.unscopables\n    if (prop === Symbol.unscopables) {\n      // Safe to return a primal realm Object here because the only code that\n      // can do a get() on a non-string is the internals of with() itself,\n      // and the only thing it does is to look for properties on it. User\n      // code cannot do a lookup on non-strings.\n      return undefined;\n    }\n\n    // Properties of the global.\n    if (prop in target) {\n      return target[prop];\n    }\n    // Prevent the lookup for other properties.\n    return undefined;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  set(target, prop, value) {\n    // Set the value on the shadow. The target itself is an empty\n    // object that is only used to prevent a frozen eval property.\n    // todo: use this.shadowTarget, for speedup\n\n    // new todo: allow modifications when target.hasOwnProperty(prop) and it\n    // is writable, assuming we've already rejected overlap (see\n    // createSafeEvaluatorFactory.factory). This TypeError gets replaced with\n    // target[prop] = value\n    if (objectHasOwnProperty(target, prop)) {\n      // todo: shim integrity: TypeError, String\n      throw new TypeError(`do not modify endowments like ${String(prop)}`);\n    }\n    getPrototypeOf(target)[prop] = value;\n    // Return true after successful set.\n    return true;\n  }\n\n  // we need has() to return false for some names to prevent the lookup  from\n  // climbing the scope chain and eventually reaching the unsafeGlobal\n  // object, which is bad.\n\n  // note: unscopables! every string in Object[Symbol.unscopables]\n\n  // todo: we'd like to just have has() return true for everything, and then\n  // use get() to raise a ReferenceError for anything not on the safe global.\n  // But we want to be compatible with ReferenceError in the normal case and\n  // the lack of ReferenceError in the 'typeof' case. Must either reliably\n  // distinguish these two cases (the trap behavior might be different), or\n  // we rely on a mandatory source-to-source transform to change 'typeof abc'\n  // to XXX. We already need a mandatory parse to prevent the 'import' and\n  // 'import.meta' expressions, since they're special forms instead of merely\n  // being a global variable\n\n  // note: if we make has() return true always, then we must implement a\n  // set() trap to avoid subverting the protection of strict mode (it would\n  // accept assignments to undefined globals, when it ought to throw\n  // ReferenceError for such assignments)\n\n  has(target, prop) {\n    // proxies stringify 'prop', so no TOCTTOU danger here\n    if (prop === 'eval') {\n      return true;\n    }\n    if (prop === 'arguments') {\n      return false;\n    }\n    if (prop in target) {\n      return true;\n    }\n    // hide all properties of unsafeGlobal at the expense of 'typeof' being\n    // wrong for those properties\n    if (prop in this.unsafeGlobal) {\n      // in browser, 'document = 3', this will add a property to your safeGlobal\n      return true;\n    }\n    return false;\n  }\n}\n"],"names":["createRealmFacade","unsafeRec","BaseRealm","unsafeEval","buildChildRealmString","getSharedGlobalDescs","unsafeGlobal","descriptors","Infinity","value","NaN","undefined","name","sharedGlobalPropertyNames","writable","configurable","repairAccessors","makeDefineAccessor","method","accessor","defineProperty","objectPrototype","prop","func","result","enumerable","TypeError","asPropertyName","makeLookupAccessor","desc","base","getOwnPropertyDescriptor","getPrototypeOf","prototype","Object","repairFunctions","repairFunction","declaration","FunctionInstance","Function","e","SyntaxError","FunctionPrototype","TamedFunction","constructor","setPrototypeOf","createUnsafeRec","allShims","sharedGlobalDescs","freeze","eval","unsafeFunction","createNewUnsafeRec","getNewUnsafeGlobal","repairAccessorsShim","repairFunctionsShim","rejectImportExpressions","s","matches","scanner","exec","linenum","split","length","throwTantrum","err","msg","console","error","stack","assert","condition","message","getOptimizableGlobals","safeGlobal","constants","descs","getOwnPropertyDescriptors","arrayForEach","getOwnPropertyNames","regexpMatch","identifierPattern","arrayPush","buildOptimizer","arrayJoin","createScopedEvaluatorFactory","optimizer","createSafeEvaluatorFactory","scopeHandler","ScopeHandler","optimizableGlobals","scopedEvaluatorFactory","endowments","scopeTarget","create","scopeProxy","Proxy","scopedEvaluator","safeEval","src","useUnsafeEvaluator","apply","createSafeEvaluator","safeEvaluatorFactory","createSafeEvaluatorWhichTakesEndowments","x","createFunctionEvaluator","safeFunction","params","functionBody","arrayPop","functionParams","stringIncludes","getUnsafeRecForRealmClass","RealmClass","UnsafeRecForRealmClass","has","get","registerUnsafeRecForRealmClass","set","getRealmRecForRealmInstance","realm","RealmRecForRealmInstance","registerRealmRecForRealmInstance","realmRec","setDefaultBindings","defineProperties","createRealmRec","safeEvalWhichTakesEndowments","initRootRealm","selfClass","self","options","newShims","shims","oldShims","arrayConcat","Realm","createRealmGlobalObject","shim","realmEvaluate","initCompartment","getRealmGlobal","callAndWrapError","target","args","eName","eMessage","eStack","ignored","Error","ErrorConstructor","errorConstructors","err2","Map","EvalError","RangeError","ReferenceError","URIError","makeRootRealm","r","makeCompartment","global","evaluate","assign","ownKeys","Reflect","uncurryThis","fn","thisArg","objectHasOwnProperty","hasOwnProperty","Array","forEach","push","pop","join","concat","RegExp","match","String","includes","isNode","exports","module","isBrowser","document","vm","require","unsafeGlobalEvalSrc","runInNewContext","iframe","createElement","style","display","body","appendChild","contentWindow","Symbol","unscopables","WeakMap","currentUnsafeRec"],"mappings":"kLAmHO,QAASA,EAAT,CAA2BC,CAA3B,CAAsCC,CAAtC,CAAiD,CACtD,KAAM,CAAEC,YAAF,EAAiBF,CAAvB,CAgBA,MAAOE,GAAWC,CAAX,EAAkCF,CAAlC,CACR,CC1DM,QAASG,EAAT,CAA8BC,CAA9B,CAA4C,CACjD,KAAMC,GAAc,CAElBC,SAAU,CAAEC,SAAF,CAFQ,CAGlBC,IAAK,CAAED,MAAOC,GAAT,CAHa,CAIlBC,UAAW,CAAEF,YAAF,CAJO,CAApB,CAOA,IAAK,KAAMG,EAAX,GAAmBC,EAAnB,CACEN,EAAYK,CAAZ,EAAoB,CAIlBH,MAAOH,EAAaM,CAAb,CAJW,CAKlBE,WALkB,CAMlBC,eANkB,CAApB,CAUF,MAAOR,EACR,CC1EM,QAASS,EAAT,EAA2B,CAehC,QAASC,EAAT,CAA4BC,CAA5B,CAAoCC,CAApC,CAA8C,CAC5CC,EAAeC,CAAf,CAAgCH,CAAhC,CAAwC,CACtCT,MAAMa,CAAN,CAAYC,CAAZ,CAAkB,CAChB,KAAMC,GAASJ,EAAe,IAAf,CAAqBE,CAArB,CAA2B,CACxC,CAACH,CAAD,EAAYI,CAD4B,CAExCE,aAFwC,CAGxCV,eAHwC,CAA3B,CAAf,CAQA,GAAI,MAAJ,CACE,KAAM,IAAIW,UAAJ,CAAe,6BAA4B,CAACJ,CAAD,CAAO,EAAlD,CAET,CAbqC,CAAxC,CAeD,CAOD,QAASK,EAAT,CAAwBL,CAAxB,CAA8B,OACR,QAAhB,QAAOA,EADiB,CAEnBA,CAFmB,CAIpB,GAAEA,CAAK,EAChB,CAED,QAASM,EAAT,CAA4BV,CAA5B,CAAoCC,CAApC,CAA8C,CAC5CC,EAAeC,CAAf,CAAgCH,CAAhC,CAAwC,CACtCT,MAAMa,CAAN,CAAY,CACVA,EAAOK,EAAeL,CAAf,CADG,IAGNO,EAHM,CAENC,EAAO,IAFD,MAIHA,GAAQ,EAAED,EAAOE,EAAyBD,CAAzB,CAA+BR,CAA/B,CAAT,CAJL,EAKRQ,EAAOE,EAAeF,CAAf,CAAP,CAEF,MAAOD,IAAQA,EAAKV,CAAL,CAChB,CATqC,CAAxC,CAWD,CAxDD,KAAM,CACJa,gBADI,CAEJZ,gBAFI,CAGJW,0BAHI,CAIJE,UAAWZ,CAJP,EAKFa,MALJ,CAgCAjB,EAAmB,kBAAnB,CAAuC,KAAvC,CAjCgC,CAkChCA,EAAmB,kBAAnB,CAAuC,KAAvC,CAlCgC,CA2DhCW,EAAmB,kBAAnB,CAAuC,KAAvC,CA3DgC,CA4DhCA,EAAmB,kBAAnB,CAAuC,KAAvC,CACD,CC5DM,QAASO,EAAT,EAA2B,CAYhC,QAASC,EAAT,CAAwBxB,CAAxB,CAA8ByB,CAA9B,CAA2C,CACzC,GAAIC,EAAJ,CACA,GAAI,CAIFA,EAAmBC,SAAU,UAASF,CAAY,EAA/B,GACpB,CAAC,MAAOG,CAAP,CAAU,CACV,GAAIA,YAAaC,YAAjB,CAEE,OAGF,KAAMD,EACP,CAdwC,KAenCE,GAAoBV,EAAeM,CAAf,CAfe,CAmBnCK,EAAgBJ,SAAS,mCAAT,CAnBmB,CAoBzCnB,EAAeuB,CAAf,CAA8B,MAA9B,CAAsC,CAAElC,MAAOG,CAAT,CAAtC,CApByC,CAkCzCQ,EAAesB,CAAf,CAAkC,aAAlC,CAAiD,CAAEjC,MAAOkC,CAAT,CAAjD,CAlCyC,CAsCzCvB,EAAeuB,CAAf,CAA8B,WAA9B,CAA2C,CAAElC,MAAOiC,CAAT,CAA3C,CAtCyC,CAwCrCC,IAAkBJ,SAASN,SAAT,CAAmBW,WAxCA,EA0CvCC,EAAeF,CAAf,CAA8BJ,SAASN,SAAT,CAAmBW,WAAjD,CAEH,CAvDD,KAAM,CAAExB,gBAAF,CAAkBY,gBAAlB,CAAkCa,gBAAlC,EAAqDX,MAA3D,CAiEAE,EAAe,UAAf,CAA2B,gBAA3B,CAlEgC,CAoEhCA,EAAe,mBAAf,CAAoC,iBAApC,CApEgC,CAqEhCA,EAAe,eAAf,CAAgC,sBAAhC,CArEgC,CAsEhCA,EAAe,wBAAf,CAAyC,uBAAzC,CACD,CCrCD,QAASU,EAAT,CAAyBxC,CAAzB,CAAuCyC,CAAvC,CAAiD,CAC/C,KAAMC,GAAoB3C,EAAqBC,CAArB,CAA1B,CAEA,MAAO2C,GAAO,CACZ3C,cADY,CAEZ0C,mBAFY,CAGZ7C,WAAYG,EAAa4C,IAHb,CAIZC,eAAgB7C,EAAaiC,QAJjB,CAKZQ,UALY,CAAP,CAOR,CAOM,QAASK,EAAT,CAA4BL,CAA5B,CAAsC,CAC3C,KAAMzC,GAAe+C,IAArB,CAGA,MAFA/C,GAAa4C,IAAb,CAAkBI,EAAlB,CAEA,CADAhD,EAAa4C,IAAb,CAAkBK,EAAlB,CACA,CAAOT,EAAgBxC,CAAhB,CAA8ByC,CAA9B,CACR,CCrEM,QAASS,EAAT,CAAiCC,CAAjC,CAAoC,CACzC,KAAMC,GAAUC,GAAQC,IAAR,CAAaH,CAAb,CAAhB,CACA,GAAIC,CAAJ,CAAa,CAIX,KAAMG,GAAUH,EAAQ,CAAR,EAAWI,KAAX,CAAiB,IAAjB,EAAuBC,MAAvC,CACA,KAAM,IAAItB,YAAJ,CAAiB,mDAAkDoB,CAAQ,EAA3E,CACP,CACF,CCbM,QAASG,EAAT,CAAsBP,CAAtB,CAAyBQ,QAAzB,CAA0C,CAC/C,KAAMC,GAAO,sCAAqCT,CAAE,EAApD,CAKAU,QAAQC,KAAR,CAAcF,CAAd,CAN+C,CAO3CD,CAP2C,GAS7CE,QAAQC,KAAR,CAAe,GAAEH,CAAI,EAArB,CAT6C,CAW7CE,QAAQC,KAAR,CAAe,GAAEH,EAAII,KAAM,EAA3B,CAX6C,EAe/C,SACA,KAAMH,EACP,CAEM,QAASI,EAAT,CAAgBC,CAAhB,CAA2BC,CAA3B,CAAoC,CACpCD,CADoC,EAEvCP,EAAc,cAAaQ,CAAQ,EAAnC,CAEH,CCDD,QAASC,EAAT,CAA+BC,CAA/B,CAA2C,MACnCC,GAAY,EADuB,CAEnCC,EAAQC,EAA0BH,CAA1B,CAF2B,CAuCzC,MAnCAI,GAAaC,EAAoBH,CAApB,CAAb,CAAyChE,GAAQ,CAC/C,KAAMiB,GAAO+C,EAAMhE,CAAN,CAAb,CACoB,QAAhB,QAAOA,EAFoC,EAS3C,CAACoE,EAAYC,EAAZ,CAA+BrE,CAA/B,CAT0C,EAsB3C,OAAKG,YAtBsC,EAuB3C,OAAKD,QAvBsC,EA6B3C,OAASe,EA7BkC,EA8B3C,OAASA,EA9BkC,EAiC/CqD,EAAUP,CAAV,CAAqB/D,CAArB,CACD,CAlCD,CAmCA,CAAO+D,CACR,CAED,QAASQ,EAAT,CAAwBR,CAAxB,CAAmC,CACjC,MAAQ,UAASS,EAAUT,CAAV,CAAqB,GAArB,CAA0B,mBAC5C,CAED,QAASU,EAAT,CAAsCpF,CAAtC,CAAiD0E,CAAjD,CAA4D,MACpD,CAAExB,gBAAF,EAAqBlD,CAD+B,CAGpDqF,EAAYH,EAAeR,CAAf,CAHwC,CAiC1D,MAAOxB,GAAgB;;QAEjBmC,CAAU;;;;;;GAFT,CASR,CAEM,QAASC,EAAT,CAAoCtF,CAApC,CAA+CyE,CAA/C,CAA2D,MAC1D,CAAEvB,gBAAF,EAAqBlD,CADqC,CAG1DuF,EAAe,GAAIC,GAAJ,CAAiBxF,CAAjB,CAH2C,CAI1DyF,EAAqBjB,EAAsBC,CAAtB,CAJqC,CAK1DiB,EAAyBN,EAA6BpF,CAA7B,CAAwCyF,CAAxC,CALiC,CAwEhE,MAjEA,UAAiBE,CAAjB,CAA6B,MASrBC,GAAcC,EAAOpB,CAAP,CAAmBG,EAA0Be,CAA1B,CAAnB,CATO,CAUrBG,EAAa,GAAIC,MAAJ,CAAUH,CAAV,CAAuBL,CAAvB,CAVQ,CAWrBS,EAAkBN,EAAuBI,CAAvB,CAXG,CAiBrBG,EAAW,CACfhD,KAAKiD,CAAL,CAAU,CACRA,EAAO,GAAEA,CAAI,EADL,CAER3C,EAAwB2C,CAAxB,CAFQ,CAGRX,EAAaY,kBAAb,GAHQ,CAIR,GAAInC,EAAJ,CACA,GAAI,CAEF,MAAOoC,GAAMJ,CAAN,CAAuBvB,CAAvB,CAAmC,CAACyB,CAAD,CAAnC,CACR,CAAC,MAAO3D,CAAP,CAAU,CAGV,KADAyB,GAAMzB,CACN,CAAMA,CACP,CAPD,OAOU,CAGJ,OAAa4D,kBAHT,GAINZ,EAAaY,kBAAb,GAJM,CAKNpC,EAAa,yCAAb,CAAwDC,CAAxD,CALM,CAOT,CACF,CArBc,EAsBff,IAvCyB,CA8D3B,MAdAL,GAAeqD,CAAf,CAAyB/C,EAAelB,SAAxC,CAcA,CAZAqC,EAAOtC,EAAekE,CAAf,EAAyBtD,WAAzB,GAAyCL,QAAhD,CAA0D,eAA1D,CAYA,CAXA+B,EAAOtC,EAAekE,CAAf,EAAyBtD,WAAzB,GAAyCO,CAAhD,CAAgE,qBAAhE,CAWA,CAPA/B,EAAe8E,CAAf,CAAyB,UAAzB,CAAqC,CACnCzF,MAAOyF,EAAS,2CAAT,CAD4B,CAEnCpF,WAFmC,CAGnCW,aAHmC,CAInCV,eAJmC,CAArC,CAOA,CAAOmF,CACR,CAGF,CAEM,QAASI,EAAT,CAA6BC,CAA7B,CAAmD,CACxD,MAAOA,GAAqB,EAArB,CACR,CAEM,QAASC,EAAT,CAAiDD,CAAjD,CAAuE,CAC5E,MAAO,CAACE,CAAD,CAAIb,CAAJ,GAAmBW,EAAqBX,CAArB,EAAiCa,CAAjC,CAC3B,CAMM,QAASC,EAAT,CAAiCzG,CAAjC,CAA4CiG,CAA5C,CAAsD,MACrD,CAAE/C,gBAAF,CAAkB7C,cAAlB,EAAmCL,CADkB,CAGrD0G,EAAe,SAAkB,GAAGC,CAArB,CAA6B,CAChD,KAAMC,GAAgB,GAAEC,EAASF,CAAT,GAAoB,EAAG,EAA/C,CACA,GAAIG,GAAkB,GAAE3B,EAAUwB,CAAV,CAAkB,GAAlB,CAAuB,EAA/C,CAUA,GAFA,GAAIzD,EAAJ,CAAmB0D,CAAnB,CAEA,CAAIG,EAAeD,CAAf,CAA+B,GAA/B,CAAJ,CAME,KAAM,IAAIzG,GAAamC,WAAjB,CACJ,2DADI,CAAN,CAO0B,CAAxB,GAAesB,MAzB6B,GA6B9CgD,GAAkB,UA7B4B,EAgChD,KAAMZ,GAAO,aAAYY,CAAe,OAAMF,CAAa,MAA3D,CAEA,MAAOX,GAASC,CAAT,CACR,CAtC0D,CA4D3D,MAlBAtD,GAAe8D,CAAf,CAA6BxD,EAAelB,SAA5C,CAkBA,CAhBAqC,EAAOtC,EAAe2E,CAAf,EAA6B/D,WAA7B,GAA6CL,QAApD,CAA8D,eAA9D,CAgBA,CAfA+B,EAAOtC,EAAe2E,CAAf,EAA6B/D,WAA7B,GAA6CO,CAApD,CAAoE,qBAApE,CAeA,CAXA/B,EAAeuF,CAAf,CAA6B,WAA7B,CAA0C,CAAElG,MAAO0C,EAAelB,SAAxB,CAA1C,CAWA,CAPAb,EAAeuF,CAAf,CAA6B,UAA7B,CAAyC,CACvClG,MAAOyF,EAAS,+CAAT,CADgC,CAEvCpF,WAFuC,CAGvCW,aAHuC,CAIvCV,eAJuC,CAAzC,CAOA,CAAO4F,CACR,CC1PD,QAASM,EAAT,CAAmCC,CAAnC,CAA+C,CAC7C,GAAIhF,OAAOgF,CAAP,IAAuBA,CAA3B,CAEE,KAAM,IAAIxF,UAAJ,CAAc,qDAAd,CAAN,CAIF,GAAI,CAACyF,GAAuBC,GAAvB,CAA2BF,CAA3B,CAAL,CAEE,KAAM,IAAIxF,UAAJ,CAAc,4BAAd,CAAN,CAEF,MAAOyF,IAAuBE,GAAvB,CAA2BH,CAA3B,CACR,CAED,QAASI,EAAT,CAAwCJ,CAAxC,CAAoDjH,CAApD,CAA+D,CAC7D,GAAIiC,OAAOgF,CAAP,IAAuBA,CAA3B,CAEE,KAAM,IAAIxF,UAAJ,CAAc,qDAAd,CAAN,CAIF,GAAIyF,GAAuBC,GAAvB,CAA2BF,CAA3B,CAAJ,CAEE,KAAM,IAAIxF,UAAJ,CAAc,4BAAd,CAAN,CAEFyF,GAAuBI,GAAvB,CAA2BL,CAA3B,CAAuCjH,CAAvC,CACD,CAOD,QAASuH,EAAT,CAAqCC,CAArC,CAA4C,CAC1C,GAAIvF,OAAOuF,CAAP,IAAkBA,CAAtB,CAEE,KAAM,IAAI/F,UAAJ,CAAc,kCAAd,CAAN,CAEF,GAAI,CAACgG,GAAyBN,GAAzB,CAA6BK,CAA7B,CAAL,CAEE,KAAM,IAAI/F,UAAJ,CACJ,oFADI,CAAN,CAIF,MAAOgG,IAAyBL,GAAzB,CAA6BI,CAA7B,CACR,CAED,QAASE,EAAT,CAA0CF,CAA1C,CAAiDG,CAAjD,CAA2D,CACzD,GAAI1F,OAAOuF,CAAP,IAAkBA,CAAtB,CAEE,KAAM,IAAI/F,UAAJ,CAAc,kDAAd,CAAN,CAEF,GAAIgG,GAAyBN,GAAzB,CAA6BK,CAA7B,CAAJ,CAEE,KAAM,IAAI/F,UAAJ,CAAc,mDAAd,CAAN,CAEFgG,GAAyBH,GAAzB,CAA6BE,CAA7B,CAAoCG,CAApC,CACD,CAGD,QAASC,EAAT,CAA4B7E,CAA5B,CAA+C0B,CAA/C,CAA2DwB,CAA3D,CAAqES,CAArE,CAAmF,CACjFmB,EAAiBpD,CAAjB,CAA6B1B,CAA7B,CADiF,CAGjF5B,EAAesD,CAAf,CAA2B,MAA3B,CAAmC,CACjCjE,MAAOyF,CAD0B,CAEjCpF,WAFiC,CAGjCC,eAHiC,CAAnC,CAHiF,CASjFK,EAAesD,CAAf,CAA2B,UAA3B,CAAuC,CACrCjE,MAAOkG,CAD8B,CAErC7F,WAFqC,CAGrCC,eAHqC,CAAvC,CAKD,CAED,QAASgH,EAAT,CAAwB9H,CAAxB,CAAmC,MAC3B,CAAE+C,mBAAF,CAAqB1C,cAArB,EAAsCL,CADX,CAG3ByE,EAAaoB,EAAOxF,EAAa4B,MAAb,CAAoBD,SAA3B,CAHc,CAI3BsE,EAAuBhB,EAA2BtF,CAA3B,CAAsCyE,CAAtC,CAJI,CAK3BwB,EAAWI,EAAoBC,CAApB,CALgB,CAM3ByB,EAA+BxB,EACnCD,CADmC,CANJ,CAS3BI,EAAeD,EAAwBzG,CAAxB,CAAmCiG,CAAnC,CATY,CAWjC2B,EAAmB7E,CAAnB,CAAsC0B,CAAtC,CAAkDwB,CAAlD,CAA4DS,CAA5D,CAXiC,CAajC,KAAMiB,GAAW3E,EAAO,CACtByB,YADsB,CAEtBwB,UAFsB,CAGtB8B,8BAHsB,CAItBrB,cAJsB,CAAP,CAAjB,CAOA,MAAOiB,EACR,CAED,QAASK,EAAT,CAAuBC,CAAvB,CAAkCC,CAAlC,CAAwCC,CAAxC,CAAiD,CAC/CA,EAAUlG,OAAOkG,CAAP,CADqC,MASzCC,GAAWD,EAAQE,KAAR,EAAiB,EATa,CAUzC,CAAEvF,SAAUwF,CAAZ,EAAyBtB,EAA0BiB,CAA1B,CAVgB,CAYzCnF,EAAWyF,EAAYD,CAAZ,CAAsBF,CAAtB,CAZ8B,CAezCpI,EAAYmD,EAAmBL,CAAnB,CAf6B,CAoBzC0F,EAAQC,EAAwBzI,CAAxB,CApBiC,CAqB/CqH,EAA+BmB,CAA/B,CAAsCxI,CAAtC,CArB+C,CAuB/C,KAAM2H,GAAWG,EAAe9H,CAAf,CAAjB,CACA0H,EAAiCQ,CAAjC,CAAuCP,CAAvC,CAxB+C,CA2B/C,IAAK,KAAMe,EAAX,GAAmB5F,EAAnB,CAEE6F,EAAcT,CAAd,CAAoBQ,CAApB,CAEH,CAED,QAASE,EAAT,CAAyBX,CAAzB,CAAoCC,CAApC,CAA0C,MAOlClI,GAAYgH,EAA0BiB,CAA1B,CAPsB,CASlCN,EAAWG,EAAe9H,CAAf,CATuB,CAUxC0H,EAAiCQ,CAAjC,CAAuCP,CAAvC,CACD,CAED,QAASkB,EAAT,CAAwBX,CAAxB,CAA8B,CAC5B,KAAM,CAAEzD,YAAF,EAAiB8C,EAA4BW,CAA5B,CAAvB,CACA,MAAOzD,EACR,CAED,QAASkE,EAAT,CAAuBT,CAAvB,CAA6B1B,CAA7B,CAAgCb,EAAa,EAA7C,CAAiD,CAI/C,KAAM,CAAEoC,8BAAF,EAAmCR,EAA4BW,CAA5B,CAAzC,CACA,MAAOH,GAA6BvB,CAA7B,CAAgCb,CAAhC,CACR,CAID,QAAS8C,EAAT,CAAiCzI,CAAjC,CAA4C,CAC1C,KAAMwI,GAAQzI,EAAkBC,CAAlB,CAA6B,CACzCgI,eADyC,CAEzCY,iBAFyC,CAGzCC,gBAHyC,CAIzCF,eAJyC,CAA7B,CAAd,CAWA,MALA3I,GAAU+C,iBAAV,CAA4ByF,KAA5B,CAAoC,CAClChI,MAAOgI,CAD2B,CAElC3H,WAFkC,CAGlCC,eAHkC,CAKpC,CAAO0H,CACR,MR3EKrI,GAAyB,kBAxG/B,SAAyB,CAAE6H,eAAF,CAAiBY,iBAAjB,CAAkCC,gBAAlC,CAAkDF,eAAlD,CAAzB,CAA4F,CAoB1F,QAASG,EAAT,CAA0BC,CAA1B,CAAkC,GAAGC,CAArC,CAA2C,CACzC,GAAI,CACF,MAAOD,GAAO,GAAGC,CAAV,CACR,CAAC,MAAOhF,CAAP,CAAY,CACZ,GAAI/B,OAAO+B,CAAP,IAAgBA,CAApB,CAEE,KAAMA,EAAN,CAEF,GAAIiF,EAAJ,CAAWC,CAAX,CAAqBC,CAArB,CACA,GAAI,CAWFF,EAAS,GAAEjF,EAAIrD,IAAK,EAXlB,CAYFuI,EAAY,GAAElF,EAAIO,OAAQ,EAZxB,CAaF4E,EAAU,GAAEnF,EAAII,KAAM,EAGvB,CAAC,MAAOgF,CAAP,CAAgB,CAGhB,KAAM,IAAIC,MAAJ,CAAU,eAAV,CACP,CACD,KAAMC,GAAmBC,EAAkBnC,GAAlB,CAAsB6B,CAAtB,GAAgCI,KAAzD,CACA,GAAI,CACF,KAAM,IAAIC,EAAJ,CAAqBJ,CAArB,CACP,CAAC,MAAOM,CAAP,CAAa,CAEb,KADAA,GAAKpF,KAAL,CAAa+E,CACb,CAAMK,CACP,CACF,CACF,CA1DyF,KAOpF,CAAErI,gBAAF,EAAqBc,MAP+D,CASpFsH,EAAoB,GAAIE,IAAJ,CAAQ,CAChC,CAAC,WAAD,CAAcC,SAAd,CADgC,CAEhC,CAAC,YAAD,CAAeC,UAAf,CAFgC,CAGhC,CAAC,gBAAD,CAAmBC,cAAnB,CAHgC,CAIhC,CAAC,aAAD,CAAgBpH,WAAhB,CAJgC,CAKhC,CAAC,WAAD,CAAcf,SAAd,CALgC,CAMhC,CAAC,UAAD,CAAaoI,QAAb,CANgC,CAAR,CATgE,CA4D1F,KAAMrB,EAAM,CACV,MAAOsB,cAAP,CAAqB,GAAGd,CAAxB,CAA8B,CAC5B,KAAMe,GAAI,GAAIvB,EAAd,CAEA,MADAM,GAAiBd,CAAjB,CAAgCQ,CAAhC,CAAuCuB,CAAvC,CAA0C,GAAGf,CAA7C,CACA,CAAOe,CACR,CAED,MAAOC,gBAAP,CAAuB,GAAGhB,CAA1B,CAAgC,CAC9B,KAAMe,GAAI,GAAIvB,EAAd,CAEA,MADAM,GAAiBF,CAAjB,CAAkCJ,CAAlC,CAAyCuB,CAAzC,CAA4C,GAAGf,CAA/C,CACA,CAAOe,CACR,CAMD,GAAIE,OAAJ,EAAa,CAKX,MAAOnB,GAAiBD,CAAjB,CAAiC,IAAjC,CACR,CAEDqB,SAAS,GAAGlB,CAAZ,CAAkB,CAEhB,MAAOF,GAAiBH,CAAjB,CAAgC,IAAhC,CAAsC,GAAGK,CAAzC,CACR,CA5BS,CAsCZ,MAPA7H,GAAeqH,EAAMxG,SAArB,CAAgC,UAAhC,CAA4C,CAC1CxB,MAAO,IAAM,kCAD6B,CAE1CK,WAF0C,CAG1CW,aAH0C,CAI1CV,eAJ0C,CAA5C,CAOA,CAAO0H,CACR,CAK+D,IC9G1D5H,EAA4B,CAIhC,UAJgC,CAKhC,OALgC,CAMhC,YANgC,CAOhC,UAPgC,CAShC,WATgC,CAUhC,oBAVgC,CAWhC,WAXgC,CAYhC,oBAZgC,CAgBhC,OAhBgC,CAiBhC,aAjBgC,CAkBhC,SAlBgC,CAmBhC,UAnBgC,CAoBhC,MApBgC,CAqBhC,OArBgC,CAsBhC,WAtBgC,CAuBhC,cAvBgC,CAwBhC,cAxBgC,CA0BhC,WA1BgC,CA2BhC,YA3BgC,CA4BhC,YA5BgC,CA6BhC,KA7BgC,CA8BhC,QA9BgC,CA+BhC,QA/BgC,CAgChC,SAhCgC,CAiChC,OAjCgC,CAkChC,YAlCgC,CAmChC,gBAnCgC,CAoChC,QApCgC,CAqChC,KArCgC,CAuChC,QAvCgC,CAwChC,QAxCgC,CAyChC,aAzCgC,CA0ChC,WA1CgC,CA2ChC,YA3CgC,CA4ChC,mBA5CgC,CA6ChC,aA7CgC,CA8ChC,aA9CgC,CA+ChC,UA/CgC,CAgDhC,SAhDgC,CAiDhC,SAjDgC,CAsDhC,MAtDgC,CAuDhC,MAvDgC,CAwDhC,SAxDgC,CA4DhC,QA5DgC,CA6DhC,UA7DgC,CAiEhC,MAjEgC,EQKrB,CACXuJ,QADW,CAEXtE,QAFW,CAGXgC,kBAHW,CAIX1G,gBAJW,CAKX6B,QALW,CAMXlB,0BANW,CAOX8C,2BAPW,CAQXE,qBARW,CASX/C,gBATW,CAUXa,gBAVW,EAWTX,OAES,CACXmE,OADW,CAEXgE,SAFW,EAGTC,QAUEC,EAAcC,GAAM,CAACC,CAAD,CAAU,GAAGxB,CAAb,GAAsB5C,EAAMmE,CAAN,CAAUC,CAAV,CAAmBxB,CAAnB,EAInCyB,EAAuBH,EAAYrI,OAAOD,SAAP,CAAiB0I,cAA7B,EAClC7F,EAAeyF,EAAYK,MAAM3I,SAAN,CAAgB4I,OAA5B,EACf3F,EAAYqF,EAAYK,MAAM3I,SAAN,CAAgB6I,IAA5B,EACZhE,EAAWyD,EAAYK,MAAM3I,SAAN,CAAgB8I,GAA5B,EACX3F,EAAYmF,EAAYK,MAAM3I,SAAN,CAAgB+I,IAA5B,EACZxC,EAAc+B,EAAYK,MAAM3I,SAAN,CAAgBgJ,MAA5B,EACdjG,EAAcuF,EAAYW,OAAOjJ,SAAP,CAAiBkJ,KAA7B,EACdnE,EAAiBuD,EAAYa,OAAOnJ,SAAP,CAAiBoJ,QAA7B,ELlCbC,EAA4B,QAAnB,QAAOC,QAAP,EAAiD,WAAlB,QAAOC,QAC/CC,EAAgC,QAApB,QAAOC,UACzB,GAAK,CAACJ,CAAD,EAAW,CAACG,CAAb,EAA4BH,GAAUG,CAA1C,CACE,KAAM,IAAInC,MAAJ,CAAU,6CAAV,CAAN,MAEIqC,GAAKL,EAASM,QAAQ,IAAR,CAAT,QAOLC,EAAuB,kCAuBhBxI,GAAqBiI,EArBlC,UAAwC,CAEtC,KAAMhL,GAAeqL,EAAGG,eAAH,qCAArB,CAEA,MAAOxL,EACR,CAgBiC,CAdlC,UAA2C,CACzC,KAAMyL,GAASL,SAASM,aAAT,CAAuB,QAAvB,CAAf,CACAD,EAAOE,KAAP,CAAaC,OAAb,CAAuB,MAFkB,CAIzCR,SAASS,IAAT,CAAcC,WAAd,CAA0BL,CAA1B,CAJyC,CAKzC,KAAMzL,GAAeyL,EAAOM,aAAP,CAAqBnJ,IAArB,wBAArB,CAIA,MAAO5C,EACR,EA0BKgD,GAAuB,kBAAiBtC,CAAgB,OACxDuC,GAAuB,kBAAiBpB,CAAgB,OMtDvD,KAAMsD,GAAa,CAUxB7C,YAAY3C,CAAZ,CAAuB,CACrB,KAAKK,YAAL,CAAoBL,EAAUK,YADT,CAErB,KAAKH,UAAL,CAAkBF,EAAUE,UAFP,CAOrB,KAAKiG,kBAAL,GAGD,CAEDiB,IAAI2B,CAAJ,CAAY1H,CAAZ,CAAkB,OAIH,MAAT,IAJY,CAMV,UAAK8E,kBANK,EAQZ,KAAKA,kBAAL,GARY,CASL,KAAKjG,UATA,EAWP6I,EAAO9F,IAXA,CAeZ5B,IAASgL,OAAOC,WAfJ,QAwBZjL,IAAQ0H,EAxBI,CAyBPA,EAAO1H,CAAP,CAzBO,OA6BjB,CAGDiG,IAAIyB,CAAJ,CAAY1H,CAAZ,CAAkBb,CAAlB,CAAyB,CASvB,GAAIiK,EAAqB1B,CAArB,CAA6B1H,CAA7B,CAAJ,CAEE,KAAM,IAAII,UAAJ,CAAe,iCAAuCJ,CAAxC,GAA8C,EAA5D,CAAN,CAIF,MAFAU,GAAegH,CAAf,EAAuB1H,CAAvB,EAA+Bb,CAE/B,GACD,CAuBD2G,IAAI4B,CAAJ,CAAY1H,CAAZ,CAAkB,OAEH,MAAT,IAFY,EAKH,WAAT,IALY,MAQZA,IAAQ0H,EARI,MAaZ1H,IAAQ,MAAKhB,YAbD,EAkBjB,CA/GuB,MLRpBqD,IAAU,kCEeVsB,GAAoB,sBCTpBkC,GAAyB,GAAIqF,SAiC7B9E,GAA2B,GAAI8E,SAkJ/BC,GJ9GC,UAAkC,CACvC,KAAMnM,GAAe,CAAC,EAAG4C,IAAJ,yBAArB,CAGA,MAFAlC,IAEA,CADAmB,GACA,CAAOW,EAAgBxC,CAAhB,CAA8B,EAA9B,CACR,CIyGwB,GACnBmI,GAAQzI,EAAkByM,EAAlB,CAAoC,CAChDxE,eADgD,CAEhDY,iBAFgD,CAGhDC,gBAHgD,CAIhDF,eAJgD,CAApC,QAMdtB,GAA+BmB,EAA/B,CAAsCgE,EAAtC"}