{"version":3,"file":"realm-shim.min.js","sources":["../src/realmFacade.js","../src/stdlib.js","../src/accessors.js","../src/functions.js","../src/unsafeRec.js","../src/block-imports.js","../src/utilities.js","../src/evaluators.js","../src/realm.js","../src/commons.js","../src/scopeHandler.js"],"sourcesContent":["// Note: do not import anything to this file to prevent using implicit\n// dependencies.\n\n// buildChildRealm is immediately turned into a string, and this function is\n// never referenced again, because it closes over the wrong intrinsics\n\nfunction buildChildRealm({ initRootRealm, initCompartment, getRealmGlobal, realmEvaluate }) {\n  // This Object and Reflect are brand new, from a new unsafeRec, so no user\n  // code has been run or had a chance to manipulate them. We extract these\n  // properties for brevity, not for security. Don't ever run this function\n  // *after* user code has had a chance to pollute its environment, or it\n  // could be used to gain access to BaseRealm and primal-realm Error\n  // objects.\n  const { defineProperty } = Object;\n\n  const errorConstructors = new Map([\n    ['EvalError', EvalError],\n    ['RangeError', RangeError],\n    ['ReferenceError', ReferenceError],\n    ['SyntaxError', SyntaxError],\n    ['TypeError', TypeError],\n    ['URIError', URIError]\n  ]);\n\n  // Like Realm.apply except that it catches anything thrown and rethrows it\n  // as an Error from this realm\n  function callAndWrapError(target, ...args) {\n    try {\n      return target(...args);\n    } catch (err) {\n      if (Object(err) !== err) {\n        // err is a primitive value, which is safe to rethrow\n        throw err;\n      }\n      let eName, eMessage, eStack;\n      try {\n        // The child environment might seek to use 'err' to reach the\n        // parent's intrinsics and corrupt them. `${err.name}` will cause\n        // string coercion of 'err.name'. If err.name is an object (probably\n        // a String of the parent Realm), the coercion uses\n        // err.name.toString(), which is under the control of the parent. If\n        // err.name were a primitive (e.g. a number), it would use\n        // Number.toString(err.name), using the child's version of Number\n        // (which the child could modify to capture its argument for later\n        // use), however primitives don't have properties like .prototype so\n        // they aren't useful for an attack.\n        eName = `${err.name}`;\n        eMessage = `${err.message}`;\n        eStack = `${err.stack}`;\n        // eName/eMessage/eStack are now child-realm primitive strings, and\n        // safe to expose\n      } catch (ignored) {\n        // if err.name.toString() throws, keep the (parent realm) Error away\n        // from the child\n        throw new Error('unknown error');\n      }\n      const ErrorConstructor = errorConstructors.get(eName) || Error;\n      try {\n        throw new ErrorConstructor(eMessage);\n      } catch (err2) {\n        err2.stack = eStack; // replace with the captured inner stack\n        throw err2;\n      }\n    }\n  }\n\n  class Realm {\n    static makeRootRealm(...args) {\n      const r = new Realm();\n      callAndWrapError(initRootRealm, Realm, r, ...args);\n      return r;\n    }\n    static makeCompartment(...args) {\n      const r = new Realm();\n      callAndWrapError(initCompartment, Realm, r, ...args);\n      return r;\n    }\n\n    // we omit the constructor because it is empty. All the personalization\n    // takes place in one of the two static methods,\n    // makeRootRealm/makeCompartment\n\n    get global() {\n      // this is safe against being called with strange 'this' because\n      // baseGetGlobal immediately does a trademark check (it fails unless\n      // this 'this' is present in a weakmap that is only populated with\n      // legitimate Realm instances)\n      return callAndWrapError(getRealmGlobal, this);\n    }\n    evaluate(...args) {\n      // safe against strange 'this', as above\n      return callAndWrapError(realmEvaluate, this, ...args);\n    }\n  }\n\n  defineProperty(Realm.prototype, 'toString', {\n    value: () => 'function Realm() { [shim code] }',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  return Realm;\n}\n\n// the parentheses means we don't bind the 'buildChildRealm' name inside the\n// child's namespace. this would accept an anonymous function declaration.\n// function expression (not a declaration) so it has a completion value.\nconst buildChildRealmString = `'use strict'; (${buildChildRealm})`;\n\nexport function createRealmFacade(unsafeRec, BaseRealm) {\n  const { unsafeEval } = unsafeRec;\n\n  // The BaseRealm is the Realm class created by\n  // the shim. It's only valid for the context where\n  // it was parsed.\n\n  // The Realm facade is a lightweight class built in the\n  // context a different context, that provide a fully\n  // functional Realm class using the intrisics\n  // of that context.\n\n  // This process is simplified because all methods\n  // and properties on a realm instance already return\n  // values using the intrinsics of the realm's context.\n\n  // Invoke the BaseRealm constructor with Realm as the prototype.\n  return unsafeEval(buildChildRealmString)(BaseRealm);\n}\n","// All the following stdlib items have the same name on both our intrinsics\n// object and on the global object. Unlike Infinity/NaN/undefined, these\n// should all be writable and configurable.\nconst sharedGlobalPropertyNames = [\n  // *** 18.2 Function Properties of the Global Object\n\n  // 'eval', // comes from safeEval instead\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n\n  // *** 18.3 Constructor Properties of the Global Object\n\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  'Date',\n  'Error',\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  // 'Function', // comes from safeFunction instead\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  'Promise',\n  'Proxy',\n  'RangeError',\n  'ReferenceError',\n  'RegExp',\n  'Set',\n  // 'SharedArrayBuffer' // removed on Jan 5, 2018\n  'String',\n  'Symbol',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n\n  // *** 18.4 Other Properties of the Global Object\n\n  // 'Atomics', // removed on Jan 5, 2018\n  'JSON',\n  'Math',\n  'Reflect',\n\n  // *** Annex B\n\n  'escape',\n  'unescape',\n\n  // *** ECMA-402\n\n  'Intl'\n\n  // *** ESNext\n\n  // 'Realm' // Comes from createRealmGlobalObject()\n];\n\nexport function getSharedGlobalDescs(unsafeGlobal) {\n  const descriptors = {\n    // *** 18.1 Value Properties of the Global Object\n    Infinity: { value: Infinity },\n    NaN: { value: NaN },\n    undefined: { value: undefined }\n  };\n\n  for (const name of sharedGlobalPropertyNames) {\n    descriptors[name] = {\n      // todo: if there's a get/accessor on the global, do we want to invoke\n      // it or throw an error?\n      // todo: get a descriptor here, so we can check\n      value: unsafeGlobal[name],\n      writable: true,\n      configurable: true\n    };\n  }\n\n  return descriptors;\n}\n","// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * Replace the legacy accessors of Object to comply with strict mode\n * and ES2016 semantics, we do this by redefining them while in 'use strict'\n * https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__\n\nWe need this repair, but would it be included when the real realms is\nintegrated into the language. If not, what are we getting here?\n\nAlso note that this changes the primal versions.\n\nOn some platforms, the implementation of these functions act as if they are\nin sloppy mode: if they're invoked badly, they will expose the global object,\nso we need to repair these for security. Thus it is our responsibility to fix\nthis, and we need to include repairAccessors. E.g. Chrome in 2016.\n\ntodo: It would be better to detect and only repair the functions that have\nthe bug.\n */\n\n// todo: this file should be moved out to a separate repo and npm module\n\n// We use this function in two ways. We use it directly to fix the primal\n// realm's Object.prototype, and we convert it into a string to be executed\n// inside each new RootRealm to fix their Object.prototypes too. So don't\n// import anything from the outside.\n\nexport function repairAccessors() {\n  const { getPrototypeOf, defineProperties, defineProperty, getOwnPropertyDescriptor } = Object;\n\n  // TOCTTOU and .asString() games could enable attacker to skip some\n  // intermediate ancestors, so we stringify/propify this once, first.\n  function asPropertyName(prop) {\n    if (typeof prop === 'symbol') {\n      return prop;\n    }\n    return `${prop}`;\n  }\n\n  defineProperties(Object.prototype, {\n    __defineGetter__: {\n      value(prop, func) {\n        return defineProperty(this, prop, {\n          get: func,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __defineSetter__: {\n      value(prop, func) {\n        return defineProperty(this, prop, {\n          set: func,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    },\n    __lookupGetter__: {\n      value(prop) {\n        prop = asPropertyName(prop); // sanitize property name/symbol\n        let base = this;\n        let desc;\n        while (base && !(desc = getOwnPropertyDescriptor(base, prop))) {\n          base = getPrototypeOf(base);\n        }\n        return desc && desc.get;\n      }\n    },\n    __lookupSetter__: {\n      value(prop) {\n        prop = asPropertyName(prop); // sanitize property name/symbol\n        let base = this;\n        let desc;\n        while (base && !(desc = getOwnPropertyDescriptor(base, prop))) {\n          base = getPrototypeOf(base);\n        }\n        return desc && desc.set;\n      }\n    }\n  });\n}\n\nexport const repairAccessorsShim = `(${repairAccessors})();`;\n","// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\nimport { defineProperty, defineProperties, getPrototypeOf, setPrototypeOf } from './commons';\n\n/**\n * The process to repair constructors:\n * 1. Obtain the prototype from an instance of the syntax\n * 2. Create a substitute noop constructor\n * 3. Replace its prototype property with the original prototype\n * 4. Replace its prototype property's constructor with itself\n * 5. Replace its [[Prototype]] slot with the noop constructor of Function\n */\nfunction repairFunction(unsafeRec, functionName, functionDecl) {\n  const { unsafeEval, unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  let FunctionInstance;\n  try {\n    // todo: pass the whole functionDecl in, rather than building a template\n    // around it, make this look like createOptionalSyntax in intrinsics.js\n    FunctionInstance = unsafeEval(functionDecl); // step 1\n  } catch (e) {\n    if (e instanceof unsafeGlobal.SyntaxError) {\n      // Prevent failure on platforms where generators are not supported.\n      return;\n    }\n    // Re-throw\n    throw e;\n  }\n  const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n  // Block evaluation of source when calling constructor on the prototype of functions.\n  const TamedFunction = unsafeFunction('throw new Error(\"Not available\");');\n  // (new Error()).constructor does not inherit from Function, because Error\n  // was defined before ES6 classes. So we don't need to repair it too.\n  // todo: what about (Error()).constructor ?\n\n  // todo: in an ES6 class that does not inherit from anything, what does its\n  // constructor inherit from? We worry that it inherits from Function, in\n  // which case instances could give access to unsafeFunction. markm says\n  // we're fine: the constructor inherits from Object.prototype\n\n  defineProperties(TamedFunction, {\n    name: {\n      value: functionName\n    },\n    prototype: {\n      value: FunctionPrototype\n    }\n  });\n  defineProperty(FunctionPrototype, 'constructor', { value: TamedFunction });\n\n  if (TamedFunction !== unsafeFunction.prototype.constructor) {\n    // Ensures that all functions meet \"instanceof Function\" in a realm.\n    setPrototypeOf(TamedFunction, unsafeFunction.prototype.constructor);\n  }\n}\n\n/**\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that preserve SES confinement. After this block is done,\n * the originals must no longer be reachable.\n */\nexport function repairFunctions(unsafeRec) {\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other constructors need it. Note these are all reachable\n  // via syntax, so it isn't sufficient to just replace global properties\n  // with safe versions. Our main goal is to prevent access to the\n  // unsafeFunction constructor through these starting points.\n  repairFunction(unsafeRec, 'Function', '(function(){})');\n  // \"plain arrow functions\" inherit from Function.prototype\n  repairFunction(unsafeRec, 'GeneratorFunction', '(function*(){})');\n  repairFunction(unsafeRec, 'AsyncFunction', '(async function(){})');\n  repairFunction(unsafeRec, 'AsyncGeneratorFunction', '(async function*(){})');\n}\n// note: this really wants to be part of the standard, because new\n// constructors may be added in the future, reachable from syntax, and this\n// list must be updated to match\n","// this module must never be importable outside the Realm shim itself\nimport { getSharedGlobalDescs } from './stdlib';\nimport { repairAccessors, repairAccessorsShim } from './accessors';\nimport { repairFunctions } from './functions';\nimport { freeze } from './commons';\n\n// A \"context\" is a fresh unsafe Realm as given to us by existing platforms.\n// We need this to implement the shim. However, when Realms land for real,\n// this feature will be provided by the underlying engine instead.\n\n// Detection used in RollupJS.\nconst isNode = typeof exports === 'object' && typeof module !== 'undefined';\nconst isBrowser = typeof document === 'object';\nif ((!isNode && !isBrowser) || (isNode && isBrowser)) {\n  throw new Error('unexpected platform, unable to create Realm');\n}\nconst vm = isNode ? require('vm') : undefined;\n\n// note: in a node module, the top-level 'this' is not the global object\n// (it's *something* but we aren't sure what), however an indirect eval of\n// 'this' will be the correct global object.\n\nconst unsafeGlobalSrc = \"'use strict'; this\";\nconst unsafeGlobalEvalSrc = `(0, eval)(\"'use strict'; this\")`;\n\nfunction createNewUnsafeGlobalForNode() {\n  // Use unsafeGlobalEvalSrc to ensure we get the right 'this'.\n  const unsafeGlobal = vm.runInNewContext(unsafeGlobalEvalSrc);\n\n  return unsafeGlobal;\n}\n\nfunction createNewUnsafeGlobalForBrowser() {\n  const iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n\n  document.body.appendChild(iframe);\n  const unsafeGlobal = iframe.contentWindow.eval(unsafeGlobalSrc);\n  // todo: we keep the iframe attached. At one point, removing the iframe\n  // caused its global object to lose its intrinsics. todo: re-test this.\n\n  return unsafeGlobal;\n}\n\n// we only export this so test-repair.js can get an unrepaired\n// Object.prototype, to sense if this platform has the buggy behavior\nexport const getNewUnsafeGlobal = isNode\n  ? createNewUnsafeGlobalForNode\n  : createNewUnsafeGlobalForBrowser;\n\n// The unsafeRec is shim-specific. It acts as the mechanism to obtain a fresh\n// set of intrinsics together with their associated eval and Function\n// evaluators. These must be used as a matched set, since the evaluators are\n// tied to a set of intrinsics, aka the \"undeniables\". If it were possible to\n// mix-and-match them from different contexts, that would enable some\n// attacks.\nfunction createUnsafeRec(unsafeGlobal, allShims) {\n  const sharedGlobalDescs = getSharedGlobalDescs(unsafeGlobal);\n\n  return freeze({\n    unsafeGlobal,\n    sharedGlobalDescs,\n    unsafeEval: unsafeGlobal.eval,\n    unsafeFunction: unsafeGlobal.Function,\n    allShims\n  });\n}\n\n// todo: NEEDS COMMENT\nfunction sanitizeUnsafeRec(unsafeRec) {\n  // Ensures that neither the legacy accessors nor the function constructors\n  // can be used to escape the confinement of the evaluators to execute in the\n  // context.\n  repairFunctions(unsafeRec);\n  // we repair the accessors by injecting a shim string, so it gets the right types\n}\n\n// Create a new unsafeRec from a brand new context, with new intrinsics and a\n// new global object\nexport function createNewUnsafeRec(allShims) {\n  const unsafeGlobal = getNewUnsafeGlobal();\n  const unsafeRec = createUnsafeRec(unsafeGlobal, allShims);\n  sanitizeUnsafeRec(unsafeRec);\n  return unsafeRec;\n}\n\n// Create a new unsafeRec from the current context, where the Realm shim is\n// being parsed and executed, aka the \"Primal Realm\"\nexport function createCurrentUnsafeRec() {\n  const unsafeGlobal = (0, eval)(unsafeGlobalSrc);\n  const unsafeRec = createUnsafeRec(unsafeGlobal, [repairAccessorsShim]);\n  // sanitizeUnsafeRec(unsafeRec); // todo: markm not sure we want to repair functions\n  repairAccessors();\n  return unsafeRec;\n}\n","// this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n// U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n// whitespace by the parser, but not matched by /\\s/, then this would admit\n// an attack like: import\\u2028('power.js') . We're trying to distinguish\n// something like that from something like importnotreally('power.js') which\n// is perfectly safe.\n\nconst scanner = /^(.*)\\bimport\\s*(\\(|\\/\\/|\\/\\*)/m;\n\nexport function rejectImportExpressions(s) {\n  const matches = scanner.exec(s);\n  if (matches) {\n    // todo: if we have a full parser available, use it here. If there is no\n    // 'import' token in the string, we're safe.\n    // if (!parse(s).contains('import')) return;\n    const linenum = matches[1].split('\\n').length; // more or less\n    throw new SyntaxError(`possible import expression rejected around line ${linenum}`);\n  }\n}\n","// we'd like to abandon, but we can't, so just scream and break a lot of\n// stuff. However, since we aren't really aborting the process, be careful to\n// not throw an Error object which could be captured by child-Realm code and\n// used to access the (too-powerful) primal-realm Error object.\n\nexport function throwTantrum(s, err = undefined) {\n  const msg = `please report internal shim error: ${s}`;\n  // note: we really do want to log these 'should never happen' things. there\n  // might be a better way to convince the linter, though.\n  // eslint-disable-next-line no-console\n  console.log(msg);\n  if (err) {\n    // eslint-disable-next-line no-console\n    console.log(`${err}`);\n    // eslint-disable-next-line no-console\n    console.log(`${err.stack}`);\n  }\n  // eslint-disable-next-line no-debugger\n  debugger;\n  throw msg;\n}\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throwTantrum(`failed to: ${message}`);\n  }\n}\n","// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  apply,\n  arrayJoin,\n  arrayPop,\n  arrayPush,\n  create,\n  defineProperty,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  regexpMatch,\n  arrayForEach,\n  setPrototypeOf,\n  stringIncludes\n} from './commons';\nimport { ScopeHandler } from './scopeHandler';\nimport { rejectImportExpressions } from './block-imports';\nimport { assert, throwTantrum } from './utilities';\n\nconst identifierPattern = /^[a-zA-Z_$][\\w_$]*$/;\n\n// todo: think about how this interacts with endowments, check for conflicts\n// between the names being optimized and the ones added by endowments\n\nfunction getOptimizableGlobals(safeGlobal) {\n  const constants = [];\n  const descs = getOwnPropertyDescriptors(safeGlobal);\n\n  arrayForEach(getOwnPropertyNames(descs), name => {\n    const desc = descs[name];\n    if (typeof name !== 'string') return; // ignore Symbols\n\n    // admit many (but not all) legal variable names: starts with letter/_/$,\n    // continues with letter/digit/_/$ . It will reject many legal names that\n    // involve unicode characters. We use 'apply' rather than /../.match() in\n    // case RegExp has been poisoned.\n\n    if (!regexpMatch(identifierPattern, name)) return;\n\n    // getters will not have .writable, don't let the falsyness of\n    // 'undefined' trick us: test with === false, not ! . However descriptors\n    // inherit from the (potentially poisoned) global object, so we might see\n    // extra properties which weren't really there. Accessor properties have\n    // 'get/set/enumerable/configurable', while data properties have\n    // 'value/writable/enumerable/configurable'.\n\n    if (desc.configurable !== false) return;\n    if (desc.writable !== false) return;\n\n    // Check for accessor properties: we don't want to optimize these,\n    // they're obviously non-constant. Setter-only accessors will still have\n    // a 'get' property, but it will be 'undefined', so we only have to test\n    // for 'get', not 'set'\n    if ('get' in desc) return;\n    if ('set' in desc) return;\n\n    // protect against post-initialization corruption of primal realm Array\n    arrayPush(constants, name);\n  });\n  return constants;\n}\n\nfunction buildOptimizer(constants) {\n  return `const {${arrayJoin(constants, ',')}} = arguments[0];`;\n}\n\nfunction createScopedEvaluatorFactory(unsafeRec, constants) {\n  const { unsafeFunction } = unsafeRec;\n\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // first 'arguments[0]' holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches common variable names for speed\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being directly evaluated.\n\n  // everything in the 'optimizer' string is looked up in the proxy\n  // (including an 'arguments[0]', which points at the Proxy). 'function' is\n  // a keyword, not a variable, so it is not looked up. then 'eval' is looked\n  // up in the proxy, that's the first time it is looked up after\n  // useUnsafeEvaluator is turned on, so the proxy returns the real the\n  // unsafeEval, which satisfies the IsDirectEvalTrap predicate, so it uses\n  // the direct eval and gets the lexical scope. The second 'arguments[0]' is\n  // looked up in the context of the inner function. The *contents* of\n  // arguments[0], because we're using direct eval, are looked up in the\n  // Proxy, by which point the useUnsafeEvaluator switch has been flipped\n  // back to 'false', so any instances of 'eval' in that string will get the\n  // safe evaluator.\n\n  return unsafeFunction(`\n    with (arguments[0]) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n}\n\nexport function createSafeEvaluator(unsafeRec, safeGlobal) {\n  const { unsafeFunction } = unsafeRec;\n\n  // This proxy has several functions:\n  // 1. works with the sentinel to alternate between direct eval and confined eval.\n  // 2. shadows all properties of the unsafe global by declaring them as undefined.\n  // 3. resolves all existing properties of the safe global.\n  // 4. uses an empty object as the target, with the safe global as its prototype,\n  // to bypass a proxy invariant that would prevent alternating between different\n  // values of eval if the user was to freeze the eval property on the safe global.\n  const scopeHandler = new ScopeHandler(unsafeRec);\n  const scopeTarget = create(safeGlobal);\n  const scopeProxy = new Proxy(scopeTarget, scopeHandler);\n\n  const optimizableGlobals = getOptimizableGlobals(safeGlobal);\n  const scopedEvaluatorFactory = createScopedEvaluatorFactory(unsafeRec, optimizableGlobals);\n  const scopedEvaluator = scopedEvaluatorFactory(scopeProxy);\n\n  // We use the the concise method syntax to create an eval without a\n  // [[Construct]] behavior (such that the invocation \"new eval()\" throws\n  // TypeError: eval is not a constructor\"), but which still accepts a 'this'\n  // binding.\n  const safeEval = {\n    eval(src) {\n      src = `${src}`;\n      rejectImportExpressions(src);\n      scopeHandler.useUnsafeEvaluator = true;\n      let err;\n      try {\n        // Ensure that \"this\" resolves to the safe global.\n        return apply(scopedEvaluator, safeGlobal, [src]);\n      } catch (e) {\n        // stash the child-code error in hopes of debugging the internal failure\n        err = e;\n        throw e;\n      } finally {\n        // belt and suspenders: the proxy switches this off immediately after\n        // the first access, but just in case we clear it here too\n        if (scopeHandler.useUnsafeEvaluator !== false) {\n          scopeHandler.useUnsafeEvaluator = false;\n          throwTantrum('handler sets useUnsafeEvaluator = false', err);\n        }\n      }\n    }\n  }.eval;\n\n  // safeEval's prototype is currently the primal realm's Function.prototype,\n  // which we must not let escape. To make 'eval instanceof Function' be true\n  // inside the realm, we need to point it at the RootRealm's value.\n\n  // Ensure that eval from any compartment in a root realm is an\n  // instance of Function in any compartment of the same root realm.\n  setPrototypeOf(safeEval, unsafeFunction.prototype);\n\n  assert(getPrototypeOf(safeEval).constructor !== Function, 'hide Function');\n  assert(getPrototypeOf(safeEval).constructor !== unsafeFunction, 'hide unsafeFunction');\n\n  // note: be careful to not leak our primal Function.prototype by setting\n  // this to a plain arrow function. Now that we have safeEval, use it.\n  defineProperty(safeEval, 'toString', {\n    value: safeEval(\"() => 'function eval() { [shim code] }'\"),\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  return safeEval;\n}\n\n/**\n * A safe version of the native Function which relies on\n * the safety of evalEvaluator for confinement.\n */\nexport function createFunctionEvaluator(unsafeRec, safeEval) {\n  const { unsafeFunction, unsafeGlobal } = unsafeRec;\n\n  const safeFunction = function Function(...params) {\n    const functionBody = `${arrayPop(params) || ''}`;\n    let functionParams = `${arrayJoin(params, ',')}`;\n\n    // Is this a real functionBody, or is someone attempting an injection\n    // attack? This will throw a SyntaxError if the string is not actually a\n    // function body. We coerce the body into a real string above to prevent\n    // someone from passing an object with a toString() that returns a safe\n    // string the first time, but an evil string the second time.\n    // eslint-disable-next-line no-new, new-cap\n    new unsafeFunction(functionBody);\n\n    if (stringIncludes(functionParams, ')')) {\n      // If the formal parameters string include ) - an illegal\n      // character - it may make the combined function expression\n      // compile. We avoid this problem by checking for this early on.\n\n      // note: v8 throws just like this does, but chrome accepts e.g. 'a = new Date()'\n      throw new unsafeGlobal.SyntaxError(\n        'shim limitation: Function arg string contains parenthesis'\n      );\n      // todo: shim integrity threat if they change SyntaxError\n    }\n\n    // todo: check to make sure this .length is safe. markm says safe.\n    if (functionParams.length > 0) {\n      // If the formal parameters include an unbalanced block comment, the\n      // function must be rejected. Since JavaScript does not allow nested\n      // comments we can include a trailing block comment to catch this.\n      functionParams += '\\n/*``*/';\n    }\n\n    const src = `(function(${functionParams}){\\n${functionBody}\\n})`;\n\n    return safeEval(src);\n  };\n\n  // Ensure that Function from any compartment in a root realm can be used\n  // with instance checks in any compartment of the same root realm.\n  setPrototypeOf(safeFunction, unsafeFunction.prototype);\n\n  assert(getPrototypeOf(safeFunction).constructor !== Function, 'hide Function');\n  assert(getPrototypeOf(safeFunction).constructor !== unsafeFunction, 'hide unsafeFunction');\n\n  // Ensure that any function created in any compartment in a root realm is an\n  // instance of Function in any compartment of the same root ralm.\n  defineProperty(safeFunction, 'prototype', { value: unsafeFunction.prototype });\n\n  // Provide a custom output without overwriting the Function.prototype.toString\n  // which is called by some third-party libraries.\n  defineProperty(safeFunction, 'toString', {\n    value: safeEval(\"() => 'function Function() { [shim code] }'\"),\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  return safeFunction;\n}\n","import { createRealmFacade } from './realmFacade';\nimport { createNewUnsafeRec, createCurrentUnsafeRec } from './unsafeRec';\nimport { createSafeEvaluator, createFunctionEvaluator } from './evaluators';\nimport { create, defineProperty, defineProperties, freeze, arrayConcat } from './commons';\n\n// Create a registry to mimic a private static members on the realm classes.\n// We define it in the same module and do not export it.\n\nconst UnsafeRecForRealmClass = new WeakMap();\n\nfunction getUnsafeRecForRealmClass(RealmClass) {\n  if (Object(RealmClass) !== RealmClass) {\n    // Detect non-objects.\n    throw new TypeError('internal error: bad object, not a Realm constructor');\n  }\n  // spec just says throw TypeError\n  // todo: but shim should include a message\n  if (!UnsafeRecForRealmClass.has(RealmClass)) {\n    // RealmClass has no unsafeRec. Shoud not proceed.\n    throw new TypeError('internal error: bad object');\n  }\n  return UnsafeRecForRealmClass.get(RealmClass);\n}\n\nfunction registerUnsafeRecForRealmClass(RealmClass, unsafeRec) {\n  if (Object(RealmClass) !== RealmClass) {\n    // Detect non-objects.\n    throw new TypeError('internal error: bad object, not a Realm constructor');\n  }\n  // spec just says throw TypeError\n  // todo: but shim should include a message\n  if (UnsafeRecForRealmClass.has(RealmClass)) {\n    // Attempt to change an existing unsafeRec on a Realm. Shoud not proceed.\n    throw new TypeError('internal error: bad object');\n  }\n  UnsafeRecForRealmClass.set(RealmClass, unsafeRec);\n}\n\n// Create a registry to mimic a private members on the realm imtances.\n// We define it in the same module and do not export it.\n\nconst RealmRecForRealmInstance = new WeakMap();\n\nfunction getRealmRecForRealmInstance(realm) {\n  if (Object(realm) !== realm) {\n    // Detect non-objects.\n    throw new TypeError('bad object, not a Realm instance');\n  }\n  if (!RealmRecForRealmInstance.has(realm)) {\n    // Realm instance has no realmRec. Should not proceed.\n    throw new TypeError(\n      'bad object, use Realm.makeRootRealm() or .makeCompartment() instead of \"new Realm\"'\n    );\n  }\n  return RealmRecForRealmInstance.get(realm);\n}\n\nfunction registerRealmRecForRealmInstance(realm, realmRec) {\n  if (Object(realm) !== realm) {\n    // Detect non-objects.\n    throw new TypeError('internal error: bad object, not a Realm instance');\n  }\n  if (RealmRecForRealmInstance.has(realm)) {\n    // Attempt to change an existing realmRec on a realm instance. Should not proceed.\n    throw new TypeError('internal error: Realm instance is already present');\n  }\n  RealmRecForRealmInstance.set(realm, realmRec);\n}\n\n// Initialize the global variables for the new Realm.\nfunction setDefaultBindings(sharedGlobalDescs, safeGlobal, safeEval, safeFunction) {\n  defineProperties(safeGlobal, sharedGlobalDescs);\n\n  defineProperty(safeGlobal, 'eval', {\n    value: safeEval,\n    writable: true,\n    configurable: true\n  });\n\n  defineProperty(safeGlobal, 'Function', {\n    value: safeFunction,\n    writable: true,\n    configurable: true\n  });\n}\n\nfunction createRealmRec(unsafeRec) {\n  const { sharedGlobalDescs, unsafeGlobal } = unsafeRec;\n\n  const safeGlobal = create(unsafeGlobal.Object.prototype);\n  const safeEval = createSafeEvaluator(unsafeRec, safeGlobal);\n  const safeFunction = createFunctionEvaluator(unsafeRec, safeEval);\n\n  setDefaultBindings(sharedGlobalDescs, safeGlobal, safeEval, safeFunction);\n\n  const realmRec = freeze({\n    safeGlobal,\n    safeEval,\n    safeFunction\n  });\n\n  return realmRec;\n}\n\nfunction initRootRealm(selfClass, self, options) {\n  options = Object(options); // Todo: sanitize\n  // note: 'self' is the instance of the Realm, and 'selfClass' is the\n  // Realm constructor (facade) we build in buildChildRealm().\n\n  // In 'undefined' mode, intrinics are not provided, we create a root\n  // realm using the fresh set of new intrinics from a new context.\n\n  // todo: investigate attacks via Array.species\n  const newShims = options.shims || [];\n  const { allShims: oldShims } = getUnsafeRecForRealmClass(selfClass);\n  // todo: this accepts newShims='string', but it should reject that\n  const allShims = arrayConcat(oldShims, newShims);\n\n  // The unsafe record is returned with its constructors repaired.\n  const unsafeRec = createNewUnsafeRec(allShims);\n\n  // Define Realm onto new sharedGlobalDescs, so it can be copied onto the\n  // safeGlobal like the rest of the .\n  // eslint-disable-next-line no-use-before-define\n  const Realm = createRealmGlobalObject(unsafeRec);\n  registerUnsafeRecForRealmClass(Realm, unsafeRec);\n\n  const realmRec = createRealmRec(unsafeRec);\n  registerRealmRecForRealmInstance(self, realmRec);\n  // Now run all shims in the new RootRealm. We don't do this for\n  // compartments\n  for (const shim of allShims) {\n    // eslint-disable-next-line no-use-before-define\n    realmEvaluate(self, shim);\n  }\n}\n\nfunction initCompartment(selfClass, self) {\n  // note: 'self' is the instance of the Realm, and 'selfClass' is the\n  // Realm constructor (facade) we build in buildChildRealm().\n\n  // In \"inherit\" mode, we create a compartment realm and inherit\n  // the context since we share the intrinsics. We create a new\n  // set to allow us to define eval() and Function() for the realm.\n  const unsafeRec = getUnsafeRecForRealmClass(selfClass);\n\n  const realmRec = createRealmRec(unsafeRec);\n  registerRealmRecForRealmInstance(self, realmRec);\n}\n\nfunction getRealmGlobal(self) {\n  const { safeGlobal } = getRealmRecForRealmInstance(self);\n  return safeGlobal;\n}\n\nfunction realmEvaluate(self, x) {\n  const { safeEval } = getRealmRecForRealmInstance(self);\n  return safeEval(x);\n}\n\n// Define Realm onto new sharedGlobalDescs, so it can be defined in the\n// safeGlobal like the rest of the shared globals.\nfunction createRealmGlobalObject(unsafeRec) {\n  const Realm = createRealmFacade(unsafeRec, {\n    initRootRealm,\n    initCompartment,\n    getRealmGlobal,\n    realmEvaluate\n  });\n  unsafeRec.sharedGlobalDescs.Realm = {\n    value: Realm,\n    writable: true,\n    configurable: true\n  };\n  return Realm;\n}\n\n// Create the current unsafeRec from the current \"primal\" realm (the realm\n// where the Realm shim is loaded and executed).\nconst currentUnsafeRec = createCurrentUnsafeRec();\nconst Realm = createRealmFacade(currentUnsafeRec, {\n  initRootRealm,\n  initCompartment,\n  getRealmGlobal,\n  realmEvaluate\n});\nregisterUnsafeRecForRealmClass(Realm, currentUnsafeRec);\n\nexport default Realm;\n","// Declare shorthand functions. Sharing these declarations across modules\n// improves both consistency and minification. Unused declarations are\n// dropped by the tree shaking process.\n\n// we capture these, not just for brevity, but for security. If any code\n// modifies Object to change what 'assign' points to, the Realm shim would be\n// corrupted.\n\nexport const {\n  assign,\n  create,\n  defineProperties,\n  defineProperty,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  setPrototypeOf\n} = Object;\n\nexport const {\n  apply,\n  ownKeys // Reflect.ownKeys includes Symbols and unenumerables, unlike Object.keys()\n} = Reflect;\n\n// See http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n// which only lives at http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n// (the native call is about 10x faster on FF than chrome)\n// this version of uncurryThis is about 100x slower on FF, equal on chrome, 2x slower on Safari\n// const bind = Function.prototype.bind;\n// const uncurryThis = bind.bind(bind.call);\n\n// this version is about 10x slower on FF, equal on chrome, 2x slower on Safari\nconst uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);\n\n// We also capture these for security: changes to Array.prototype after the\n// Realm shim runs shouldn't affect subsequent Realm operations.\nexport const objectHasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty),\n  arrayForEach = uncurryThis(Array.prototype.forEach),\n  arrayPush = uncurryThis(Array.prototype.push),\n  arrayPop = uncurryThis(Array.prototype.pop),\n  arrayJoin = uncurryThis(Array.prototype.join),\n  arrayConcat = uncurryThis(Array.prototype.concat),\n  regexpMatch = uncurryThis(RegExp.prototype.match),\n  stringIncludes = uncurryThis(String.prototype.includes);\n","// the ScopeHandler manages a Proxy which serves as the global scope for the\n// safeEvaluator operation (the Proxy is the argument of a 'with' binding).\n// As described in createSafeEvaluator(), it has several functions:\n// * allow the very first (and only the very first) use of 'eval' to map to\n//   the real (unsafe) eval function, so it acts as a 'direct eval' and can\n//   access its lexical scope (which maps to the 'with' binding, which the\n//   ScopeHandler also controls)\n// * ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n//   which lives as the 'eval' property of the safeGlobal\n// * route all other property lookups at the safeGlobal\n// * hide the unsafeGlobal which lives on the scope chain above the 'with'\n// * ensure the Proxy invariants despite some global properties being frozen\n\nimport { getPrototypeOf } from './commons';\n\nexport class ScopeHandler {\n  // Properties stored on the handler are not available from the proxy.\n\n  // the Proxy is only used by with(), so the Handler only needs to implement\n  // a few properties: has, get, set (which we leave at the default)\n\n  // todo: throw if any traps other than get/set/has are run (e.g.\n  // getOwnPropertyDescriptors, apply, getPrototypeOf) . Make this handler\n  // inherit from a second one whose 'get' property always throws.\n\n  constructor(unsafeRec) {\n    this.unsafeGlobal = unsafeRec.unsafeGlobal;\n    this.unsafeEval = unsafeRec.unsafeEval;\n\n    // this flag allow us to determine if the eval() call is a controlled\n    // eval done by the realm's code or if it is user-land invocation, so\n    // we can react differently.\n    this.useUnsafeEvaluator = false;\n\n    // todo: this.shadowTarget = getPrototypeOf(somehow_get_target)\n  }\n\n  get(target, prop) {\n    // Special treatment for eval. The very first lookup of 'eval' gets the\n    // unsafe (real direct) eval, so it will get the lexical scope that uses\n    // the 'with' context.\n    if (prop === 'eval') {\n      // test that it is true rather than merely truthy\n      if (this.useUnsafeEvaluator === true) {\n        // reset before use\n        this.useUnsafeEvaluator = false;\n        return this.unsafeEval;\n      }\n      return target.eval;\n    }\n\n    if (prop === Symbol.unscopables) {\n      // Safe to return a primal realm Object here because the only code that\n      // can do a get() on a non-string is the internals of with() itself,\n      // and the only thing it does is to look for properties on it. User\n      // code cannot do a lookup on non-strings.\n      return undefined;\n    }\n\n    // Properties of the global.\n    if (prop in target) {\n      return target[prop];\n    }\n    // Prevent the lookup for other properties.\n    return undefined;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  set(target, prop, value) {\n    // Set the value on the shadow. The target itself is an empty\n    // object that is only used to prevent a froxen eval property.\n    // todo: use this.shadowTarget, for speedup\n    getPrototypeOf(target)[prop] = value;\n    // Return true after successful set.\n    return true;\n  }\n\n  // we need has() to return false for some names to prevent the lookup  from\n  // climbing the scope chain and eventually reaching the unsafeGlobal\n  // object, which is bad.\n\n  // note: unscopables! every string in Object[Symbol.unscopables]\n\n  // todo: we'd like to just have has() return true for everything, and then\n  // use get() to raise a ReferenceError for anything not on the safe global.\n  // But we want to be compatible with ReferenceError in the normal case and\n  // the lack of ReferenceError in the 'typeof' case. Must either reliably\n  // distinguish these two cases (the trap behavior might be different), or\n  // we rely on a mandatory source-to-source transform to change 'typeof abc'\n  // to XXX. We already need a mandatory parse to prevent the 'import' and\n  // 'import.meta' expressions, since they're special forms instead of merely\n  // being a global variable\n\n  // note: if we make has() return true always, then we must implement a\n  // set() trap to avoid subverting the protection of strict mode (it would\n  // accept assignments to undefined globals, when it ought to throw\n  // ReferenceError for such assignments)\n\n  has(target, prop) {\n    // proxies stringify 'prop', so no TOCTTOU danger here\n    if (prop === 'eval') {\n      return true;\n    }\n    if (prop === 'arguments') {\n      return false;\n    }\n    if (prop in target) {\n      return true;\n    }\n    // hide all properties of unsafeGlobal at the expense of 'typeof' being\n    // wrong for those properties\n    if (prop in this.unsafeGlobal) {\n      // in browser, 'document = 3', this will add a property to your safeGlobal\n      return true;\n    }\n    return false;\n  }\n}\n"],"names":["unsafeEval","Infinity","value","NaN","undefined","writable","configurable","getPrototypeOf","defineProperties","defineProperty","getOwnPropertyDescriptor","Object","prototype","__defineGetter__","get","enumerable","__defineSetter__","set","__lookupGetter__","__lookupSetter__","unsafeFunction","unsafeGlobal","SyntaxError","name","constructor","sharedGlobalDescs","eval","Function","allShims","exec","split","length","console","log","stack","Proxy","useUnsafeEvaluator","TypeError","has","safeGlobal","safeEval","safeFunction","shims","initRootRealm","initCompartment","getRealmGlobal","realmEvaluate","Realm","message","Error","Map","EvalError","RangeError","ReferenceError","URIError","makeRootRealm","makeCompartment","global","evaluate","assign","create","freeze","getOwnPropertyDescriptors","getOwnPropertyNames","setPrototypeOf","apply","ownKeys","Reflect","Array","forEach","push","pop","join","concat","RegExp","match","String","includes","exports","module","document","require","runInNewContext","createElement","style","display","body","appendChild","contentWindow","Symbol","unscopables","WeakMap"],"mappings":"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"}